{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to VoltScript JSON Converter documentation","text":"<p>VoltScript JSON Converter is a VoltScript library that provides classes for configured deserialization / serialization of JSON. To get a general idea, see the simple deserialization / serialization examples.</p>"},{"location":"index.html#whats-new","title":"What's new","text":"<p>For the latest release information about VoltScript JSON Converter, see What's new.</p>"},{"location":"index.html#using-via-dependency-management","title":"Using via dependency management","text":"<p>For using with dependency management, see Use dependency management.</p>"},{"location":"index.html#how-the-documentation-is-organized","title":"How the documentation is organized","text":"<p>The documentation is based on the Di\u00e1taxis framework, which organizes documentation into the following modes to address users' documentation needs at different times and in different circumstances. Below shows an overview that guides you on where to look for needed information:</p> <p>Tutorials - Hands-on introduction on how to use VoltScript JSON Converter</p> <p>How-to guides - Practical step-by-step guides for performing tasks and operation</p> <p>Topic guides - High-level discussion and explanation of key topics and concepts in VoltScript JSON Converter</p> <p>References - Contain API documentation and test reports</p>"},{"location":"howto/index.html","title":"How-to guides","text":"<p>How-to guides instruct users in completing key goals and tasks related to VoltScript JSON Converter.</p> <ul> <li>Deserialization</li> <li>Serialization</li> <li>Get Verbose Logging</li> <li>Use dependency management</li> <li>Error handling</li> <li>Loading LogWriters from JSON</li> </ul>"},{"location":"howto/archipelago.html","title":"Use dependency management","text":"<p>Info</p> <p>For generic how-to information about VoltScript Dependency Management, see VoltScript documentation.</p> <p>Dependency management is available in the documentation for each project, but also aggregated here:</p>"},{"location":"howto/archipelago.html#authentication","title":"Authentication","text":"<p>You'll need a Personal Access Token to use GitHub REST APIs. You'll then need to add the following to the JSON object in your atlas-settings.json in the <code>.vss</code> directory of your user home directory:</p> <pre><code>    \"hcl-github\": {\n        \"type\": \"github\",\n        \"token\": \"${env.TOKEN}\"\n    },\n    \"volt-mx-marketplace\": {\n        \"type\": \"marketplace\",\n        \"username\": \"YOUR_USERNAME\",\n        \"password\": \"YOUR_PASSWORD\",\n        \"authUrl\": \"https://accounts.auth.demo-hclvoltmx.net/login\"\n    }\n</code></pre>"},{"location":"howto/archipelago.html#repository","title":"Repository","text":"<p>You'll need to add the following to your repositories object in the <code>atlas.json</code> of your project:</p> <pre><code>        {\n            \"id\": \"hcl-github\",\n            \"type\": \"github\",\n            \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\"\n        }\n</code></pre>"},{"location":"howto/archipelago.html#dependency","title":"Dependency","text":"<p>You'll need to add the following relevant dependency to your dependencies or testDependencies object in the <code>atlas.json</code> of your project:</p> <pre><code>        {\n            \"library\": \"voltscript-json-converter\",\n            \"version\": \"1.0.5\",\n            \"module\": \"VoltScriptJsonConverter.vss\",\n            \"repository\": \"hcl-github\"\n        }\n</code></pre>"},{"location":"howto/errorhandling.html","title":"Error handling","text":""},{"location":"howto/errorhandling.html#using-voltscript-logging","title":"Using VoltScript Logging","text":"<p>VoltScript JSON Converter makes use of VoltScript Logging, which provides the ability to track and log error information.</p> <p>Important</p> <p>To retrieve output, you must add at least one LogWriter to the <code>globalLogSession</code> and ensure the code does not abort with an uncaught error, or logs do not get written.</p>"},{"location":"howto/errorhandling.html#voltscript-json-converter-behavior","title":"VoltScript JSON Converter behavior","text":"<p>The intention when adding error handling to VoltScript JSON Converter has been to optimize the development experience as much as possible, so that when bad data (inevitably) is submitted, you can fix the data and process successfully as quickly as possible.</p> <ul> <li>To process as much of the JSON as possible before returning an error.</li> <li>To notify you of as many problems with the JSON.</li> <li>If a constructor fails, obviously we cannot check the serialization of properties.</li> <li>If <code>suppressErrors</code> is set to True, errors with setting properties are not logged. If errors occur, the property will remain as the default value for that datatype (\"\" for a string, 0 for a number, False for a boolean etc).</li> <li>When <code>suppressErrors</code> is set to True, if a constructor fails, an error will still be thrown.</li> </ul> <p>Note</p> <p>When building code for a constructor, the scalar values will be extracted from the JSON object. But there is no way to know what datatype the code for the constructor expects. This can result in a JSON object containing a String for a property, but the constructor expects an Integer, causing the constructor code to fail with no way to successfully create the relevant Object.</p>"},{"location":"howto/errorhandling.html#json-arrays-suppresserrors-and-constructor-errors","title":"JSON arrays, suppressErrors and constructor errors","text":"<p>But remember that first point, to process as much of the JSON as possible. That changes how an error thrown from invalid constructor code should be handled when converting JSON objects to VoltScript objects.</p> <pre><code>flowchart TD\nA([Start]) --&gt; B(Process JSON array)\nB --&gt; C(Process JSON Object)\nC --&gt; D(Create VoltScript object)\nD --&gt; E{Error encountered}\nE -- No --&gt; F(Deserialize properties)\nF --&gt; G{More objects?}\nG -- Yes --&gt; C\nE -- Yes --&gt; H(Throw error)\nH --&gt; J(Create custom ErrorEntry&lt;BR/&gt;logging array index)\nJ --&gt; K(Set Variant index to Nothing)\nK --&gt; G\nG -- No --&gt; L{Is suppressErrors False}\nL -- No --&gt; M([Return Variant array])\nL -- Yes --&gt; N{Were there errors?}\nN -- No --&gt; M\nN -- Yes --&gt; O([Throw error])</code></pre> <p>You can find all detailed errors for individual array elements by querying the ErrorSession or checking the logs, if you have added a LogWriter to the LogSession.</p> <p>Tip</p> <p>When parameters are extracted for custom constructors or custom setters, we cannot identify the data type the method signature expects. When adding the parameter to the custom constructor or custom setter, you can define the default value to use if the JSON object doesn't have that label. But it's not possible to identify the datatype of the variable declaration for the default value - a String is a String, whether it's stored in a String variable or Variant variable. And there are valid use cases where method signatures should accept a Variant of differing datatypes.</p> <p>So if a JSON object contains a value for a specific label, it will just be passed as-is to the custom constructor or custom setter. It is the developer's responsibility to ensure the JSON value is of a valid datatype, or return the error message and require the user to fix up the data.</p> <p>Best practice is to validate the JSON object before using VoltScript JSON Converter. You can see that paradigm in practice in <code>loadLogWritersFromJson()</code>, which calls <code>validateWriterJson()</code> to validate each LogWriter JSON object. The same approach is also done in VoltScript's dependency management, in <code>archipelago_functions.vss</code>.</p>"},{"location":"howto/jsonlogwriters.html","title":"Loading LogWriters from JSON","text":""},{"location":"howto/jsonlogwriters.html#loading-logwriters","title":"Loading LogWriters","text":"<p>To load LogWriters from in-memory, the best practice approach would be:</p> <ol> <li>Build a JSON object that conforms to the schema above, using JsonVSE.</li> <li>Call <code>toString(False)</code>method to convert it to a JSON string.</li> <li>Pass the string to <code>loadLogWritersFromJson()</code>.</li> </ol> <p>To load from a file:</p> <ol> <li>Get the filepath as a string relative to the project directory.</li> <li>Pass the string to <code>loadLogWritersFromJson()</code>.</li> </ol> <p>The LogWriters created will automatically be added to the <code>globalLogSession</code>. The function will also return a Variant array of LogWriter objects, if you wish to do additional processing, for example removing specific LogWriters based on particular business logic.</p>"},{"location":"howto/jsonlogwriters.html#writing-logwriter-json-files","title":"Writing LogWriter JSON files","text":"<p>The \"VoltScript Build Manager\" Visual Studio Code extension will validate JSON against the schema, providing the filename ends \"vslogging.conf\". There is also a snippet available with the snippet prefix \"vslogging\". This is the recommended approach.</p> <p>All property name in <code>constructorArgs</code> should also exist in <code>constructorOrder</code>. However, a JSON schema cannot validate this. So if you omit one or type its name incorrectly, you will not be warned when saving the file.</p>"},{"location":"howto/troubleshooting.html","title":"Get Verbose Logging","text":""},{"location":"howto/troubleshooting.html#verbose-logging","title":"Verbose Logging","text":"<p>Verbose logging can be enabled by calling <code>JsonConversionHelper.enableDebug()</code> before running the conversion. This will create <code>LogEntry</code> objects for each message. However, because this goes through <code>DebugPrint_Samsara</code> function, the line number will be within that function. Use <code>{{CALLEELINENUM}}</code> to get the actual line number.</p> <p>Important</p> <p><code>{{CALLEELINENUM}}</code> is only available in VoltScript Logging 1.0.1.</p> <p>If you are re-using the same <code>JsonConversionHelper</code> multiple times and want to reset it, you can do so by calling <code>JsonConversionHelper.disableDebug()</code>.</p>"},{"location":"howto/troubleshooting.html#adding-debugging-to-custom-converters","title":"Adding debugging to Custom Converters","text":"<p>To capture if VoltScript JSON Converter is correctly calling a function you've added, you can use <code>Call samsaraTouchFunction(\"myFunctionName\")</code>.</p> <p>To log custom messages from the converter, use <code>DebugPrint_Samsara getMeTypeForDebug() &amp; \"My custom message\"</code>.</p> <p>Tip</p> <p>When parameters are extracted for custom constructors or custom setters, we cannot identify the data type the method signature expects. When adding the parameter to the custom constructor or custom setter, you can define the default value to use if the JSON object doesn't have that label. But it's not possible to identify the datatype of the variable declaration for the default value - a String is a String, whether it's stored in a String variable or Variant variable. And there are valid use cases where method signatures should accept a Variant of differing datatypes.</p> <p>So if a JSON object contains a value for a specific label, it will just be passed as-is to the custom constructor or custom setter. It is the developer's responsibility to ensure the JSON value is of a valid datatype, or return the error message and require the user to fix up the data.</p> <p>Best practice is to validate the JSON object before using VoltScript JSON Converter. You can see that paradigm in practice in <code>loadLogWritersFromJson()</code>, which calls <code>validateWriterJson()</code> to validate each LogWriter JSON object. The same approach is also done in VoltScript's dependency management, in <code>archipelago_functions.vss</code>.</p>"},{"location":"howto/deserialization/index.html","title":"Deserialization","text":"<p>Deserialization is converting a JSON object or string of JSON to a VoltScript object or array of VoltScript objects.</p> <ul> <li>Convert JSON to an Object</li> <li>Use Object and Object Array Converters</li> <li>Use and extend JsonSetterConverters</li> <li>Create a custom Converter</li> <li>Convert a JSON String to a Variant Array</li> <li>Use the JsonCustomConstructor</li> <li>Merge into existing VoltScript Object</li> </ul>"},{"location":"howto/deserialization/array-converter.html","title":"Convert a JSON string to a variant array","text":"<p>Imagine you have a JSON object that has an element <code>\"products\": \"Connections,Domino,Volt\"</code>. But your class has <code>Public products as Variant</code>, intended to hold an array of products. So your custom converter needs to take the string and split it on the comma.</p> <p>First, create your custom converter class:</p> <pre><code>Class StringToArraySerializer as AbstractJsonConverter\n\nEnd Class\n</code></pre> <p>You don't need to add a constructor - nothing changes from the base constructor. You just need to add the <code>fromJson()</code> function. This needs the same signature as the function in the base class, so <code>Function fromJson(source as JsonObject) as Variant</code>. The source being passed in will be <code>\"products\": \"Connections,Domino,Volt\"</code>.</p> <p>For the body of the function, get the string value from this \"products\" element and convert it to an array. You get the value using <code>source.scalarValue</code>. Use <code>Split()</code> to split the string into an array, based on the separator <code>,</code>. So the complete function is:</p> <pre><code>Function fromJson(source as JsonObject) as Variant\n    fromJson = Split(source.scalarValue, \",\")\nEnd Function\n</code></pre> <p>Use it with the following code:</p> <pre><code>Dim helper as New JsonConversionHelper\nDim strToArrSer as New StringToArraySerializer()\nCall helper.withCustomConverter(\"products\", strToArrSer)\n</code></pre> <p>Example code</p>"},{"location":"howto/deserialization/basic-object-converter.html","title":"Use object and object array converters","text":""},{"location":"howto/deserialization/basic-object-converter.html#basic-object-converter","title":"Basic object converter","text":"<p>Imagine you have the following JSON <code>|{\"firstName\":\"Ron\",\"lastName\":\"Burgundy\",\"pet\": {\"name\":\"Baxter\",\"type\":\"Dog\"}}|</code>.</p> <p>You want to convert it into a Person object which has a Pet, where the classes are like this:</p> <pre><code>Class Person\n\n    Public firstName as String\n    Public lastName as String\n    Public pet as Pet\n\n    Function getName() as String\n        getName = firstName &amp; \" \" &amp; lastName\n    End Function\n\nEnd Class\n\nClass Pet\n\n    Public name as String\n    Public type as String\n\nEnd Class\n</code></pre> <p>In this case, you don't need a custom converter and just use the JsonBasicObjectConverter. You can just use the following code:</p> <pre><code>Dim helper as new JsonConversionHelper()\nDim petConverter as New JsonBasicObjectConverter(\"Pet\", \"deser-20\")\nDim person as Person\nDim json as String\n\njson = |{\"firstName\":\"Ron\",\"lastName\":\"Burgundy\",\"pet\": {\"name\":\"Baxter\",\"type\":\"Dog\"}}|\nCall helper.withCustomConverter(\"pet\", petConverter)\nSet person = helper.fromJsonString(json, \"Person\", \"deser-20\")\n</code></pre>"},{"location":"howto/deserialization/basic-object-converter.html#basic-object-array-converter","title":"Basic object array converter","text":"<p>Imagine you have the following JSON <code>|{\"firstName\":\"Tom\",\"lastName\":\"Popper\",\"pets\": [{\"name\":\"Captain\",\"type\":\"Gentoo Penguin\"},{\"name\":\"Loudy\",\"type\":\"Gentoo Penguin\"},{\"name\":\"Nimrod\",\"type\":\"Gentoo Penguin\"}]}|</code>. In this case, the Person class contains an array of Pets. Again, you don't need a custom converter and just use the JsonBasicObjectArrayConverter. You can just use the following code:</p> <pre><code>Dim helper as new JsonConversionHelper()\nDim petConverter as New JsonBasicObjectArrayConverter(\"Pet\", \"deser-20\")\nDim person as ComplexPerson\nDim json as String\n\njson = |{\"firstName\":\"Tom\",\"lastName\":\"Popper\",\"pets\": [{\"name\":\"Captain\",\"type\":\"Gentoo Penguin\"},{\"name\":\"Loudy\",\"type\":\"Gentoo Penguin\"},{\"name\":\"Nimrod\",\"type\":\"Gentoo Penguin\"}]}|\nCall helper.withCustomConverter(\"pets\", petConverter)\nSet person = helper.fromJsonString(json, \"ComplexPerson\", \"../example_code/deser-20\")\n</code></pre> <p>However, you need to ensure the class is set up correctly. The <code>pets</code> property needs to be declared as a Variant, because if it were declared as a string array, it cannot be assigned, only modified. So the Person class will need to look like this:</p> <pre><code>Class ComplexPerson\n\n    Public firstName as String\n    Public lastName as String\n    Public pets as Variant\n\nEnd Class\n</code></pre> <p>Example code</p>"},{"location":"howto/deserialization/custom-constructor.html","title":"Use the JsonCustomConstructor","text":""},{"location":"howto/deserialization/custom-constructor.html#simple-example","title":"Simple example","text":"<p>Imagine the following class:</p> <pre><code>Class Session\n\n    Public id as String\n    Public title as String\n\n    Sub New(id as String, title as String)\n        Me.id = id\n        Me.title = title\n    End Sub\n\nEnd Class\n</code></pre> <p>The constructor takes parameters that will be in the JSON object being parsed. So a custom constructor is needed.</p> <p>Like the JsonSetterConverter, the JsonCustomConstructor allows you to define how to extract parameters. Out of the box, parameters can be literals or can be extracted from the current JSON object.</p> <pre><code>Dim sess as Session\nDim helper as New JsonConversionHelper\nDim sessionConstructor as new JsonCustomConstructor\nDim json as String\n\njson = |{\"id\": \"Ad01\",\"title\": \"Domino HA\"}|\nCall sessionConstructor.withParam(\"id\",\"\").withParam(\"title\", \"\")\nSet sess = helper.withCustomConstructor(sessionConstructor).fromJsonString(json, \"Session\", \"deser-70\")\n</code></pre> <p>You create a new JsonCustomConstructor and define where to find the two parameters - id and title - in that order. By adding the custom constructor to the helper, it will be picked up by the <code>toObject()</code> function of the JsonConversionHelper for creating the Session.</p> <p>Example code</p>"},{"location":"howto/deserialization/custom-constructor.html#using-a-jsoncustomconstructor-inside-a-custom-converter","title":"Using a JsonCustomConstructor inside a custom converter","text":"<p>Imagine the following classes:</p> <pre><code>Class Person\n\n    Public firstName as String\n    Public lastName as String\n    Public pet as Pet\n\nEnd Class\n\nClass Pet\n\n    Public name as String\n    Public type as String\n\n    Sub New(petName as String, petType as String)\n        Me.name = petName\n        Me.type = petType\n    End Sub\n\nEnd Class\n</code></pre> <p>You need a custom converter for the \"pet\" property, but that needs to call a custom constructor. You can do this with the following converter.</p> <pre><code>Class PetConverter as AbstractJsonConverter\n\n    Function fromJson(source as JsonObject) as Variant\n\n        Dim pet as Pet\n        Dim helper as New JsonConversionHelper()\n        Dim petConstructor as New JsonCustomConstructor()\n        Call petConstructor.withParam(\"name\", \"\").withParam(\"type\", \"\")\n        Set pet = helper.withCustomConstructor(petConstructor)._\n            toObject(source, \"Pet\", \"deser-80\")._\n            fromJson(source)\n        Set fromJson = pet\n\n    End Function\n\nEnd Class\n</code></pre> <p>On line 5, you declare a Pet object to hold the converted object and pass back from the <code>fromJson()</code> function. On line 6, you create a new <code>JsonConversionHelper</code> to perform the conversion. Then on lines 7 and 8, you create a <code>JsonCustomConstructor</code> to create the Pet object, and tell it to look for \"name\" as the first parameter and \"type\" as the second.</p> <p>On line 9, you call the helper, pass the petConstructor, and tell it to create an object of type \"Pet\" from \"ComplexPersonConstructorTest\" library from the source JSON. The source will just be the value of the \"pet\" element.</p> <p>Now you're ready to use the converter.</p> <pre><code>Dim helper as new JsonConversionHelper()\nDim petConverter as New PetConverter()\nDim person as Person\nDim json as String\n\njson = |{\"firstName\":\"Ron\",\"lastName\":\"Burgundy\",\"pet\": {\"name\":\"Baxter\",\"type\":\"Dog\"}}|\nCall helper.withCustomConverter(\"pet\", petConverter)\nSet person = helper.fromJsonString(json, \"Person\", \"deser-80\")\n</code></pre> <p>Create the petConverter and helper, pass the converter into the helper on line 7, and load it from the JSON string.</p> <p>Tip</p> <p>When parameters are extracted for custom constructors or custom setters, we cannot identify the data type the method signature expects. When adding the parameter to the custom constructor or custom setter, you can define the default value to use if the JSON object doesn't have that label. But it's not possible to identify the datatype of the variable declaration for the default value - a String is a String, whether it's stored in a String variable or Variant variable. And there are valid use cases where method signatures should accept a Variant of differing datatypes.</p> <p>So if a JSON object contains a value for a specific label, it will just be passed as-is to the custom constructor or custom setter. It is the developer's responsibility to ensure the JSON value is of a valid datatype, or return the error message and require the user to fix up the data.</p> <p>Best practice is to validate the JSON object before using VoltScript JSON Converter. You can see that paradigm in practice in <code>loadLogWritersFromJson()</code>, which calls <code>validateWriterJson()</code> to validate each LogWriter JSON object. The same approach is also done in VoltScript's dependency management, in <code>archipelago_functions.vss</code>.</p> <p>Example code</p>"},{"location":"howto/deserialization/custom-converter.html","title":"Create a custom converter","text":""},{"location":"howto/deserialization/custom-converter.html#overriding-fromjson","title":"Overriding fromJson()","text":"<p>Imagine you have a JSON object that contains an element <code>\"modified\":\"2022-02-02T02:02:22Z\"</code>, but your class has <code>Public modifiedDate as Variant</code>.</p> <p>First, create your custom converter class:</p> <pre><code>Class DateTimeSerializer as AbstractJsonConverter\n\nEnd Class\n</code></pre> <p>For the body of the <code>fromJson()</code> function, get the string value from the \"modified\" element and convert it to a DateTimeObject. So the complete function is:</p> <pre><code>Function fromJson(source As JsonObject) As Variant\n    Dim dt as String\n    Dim dateVal as String\n    Dim timeVal as String\n    Dim dateElems as Variant\n    Dim timeElems as Variant\n\n    dt = source.scalarValue\n    dateVal = StrLeft(dt, \"T\")\n    dateElems = Split(dateVal, \"-\")\n    timeVal = Left$(StrRight(dt, \"T\"), 8)\n    timeElems = Split(timeVal, \":\")\n    Return DateNumber(dateElems(0), dateElems(1), dateElems(2)) + TimeNumber(timeElems(0), timeElems(1), timeElems(2))\nEnd Function\n</code></pre> <p>You can use it with the following code:</p> <pre><code>Dim helper as New JsonConversionHelper\nDim dateConverter as New DateTimeSerializer()\nCall dateConverter.forPropertyName(\"modifiedDate\")   'Redirect value to modifiedDate property of our class\nCall helper.withCustomConverter(\"modified\", dateConverter)\nSet obj = helper.fromJsonString(json, \"ObjectSummary\", \"deser-50\")\n</code></pre> <p>This creates an instance of DateTimeSerializer, maps it to the <code>modifiedDate</code> property of the class and maps it from the <code>modified</code> element of the json.</p> <p>Warning</p> <p>Date variants are not intended to be timezone-specific. You should consider using ZuluVSE instead.</p>"},{"location":"howto/deserialization/custom-converter.html#overriding-deserialize","title":"Overriding deserialize()","text":"<p>Occasionally, just converting the value won't be enough. You might need to do something more extensive with the value you're deserializing. Imagine you have a JSON object that has an element <code>\"startTime\":\"2022-06-03T10:10:30Z\"</code>, but the class you're writing to has <code>Public startDate as Variant</code> and <code>Public startTime as Variant</code>.</p> <p>You need to take a single string coming in and split it across two Date variants, one for the date and one for the time. The standard converters aren't set up for that. <code>fromJson()</code> will return a single value to write to a single field.</p> <p>First, create your custom converter class:</p> <pre><code>Class ComplexDateTimeSerializer as AbstractJsonConverter\n\nEnd Class\n</code></pre> <p>Override the standard <code>deserialize()</code> sub, which needs the same signature as the sub in the base class, so <code>Sub deserialize(holder as JsonConversionHolder, source as JsonObject)</code>. The <code>holder</code> parameter is a JsonConversionHolder object, which has a <code>contents</code> property containing the instance of the class you're deserializing to. Your code will be:</p> <pre><code>Sub deserialize(holder as JsonConversionHolder, source as JsonObject)\n    Dim dateTime as String\n    Dim dateVal as String\n    Dim timeVal as String\n    Dim dateElems as Variant\n    Dim execString as String\n\n    Set samsaraObj = holder.contents\n\n    dateTime = source.scalarValue\n    dateVal = StrLeft(dt, \"T\")\n    dateElems = Split(dateVal, \"-\")\n    timeVal = Left$(StrRight(dt, \"T\"), 8)\n\n    ' Build execution string\n    Try\n        execString = |samsaraObj.startDate = DateNumber(| &amp; dateElems(0) &amp; |,| &amp; dateElems(1) &amp; |,| &amp; dateElems(2) &amp; |)|\n        execString = execString &amp; Chr(10) &amp; |samsaraObj.startTime = CDat(\"| &amp; timeVal &amp; |\")|\n        DebugPrint_Samsara getMeTypeForDebug() &amp; \"Executing \" &amp; execString\n        Execute execString\n        DebugPrint_Samsara getMeTypeForDebug() &amp; \"Executed \" &amp; execString\n    Catch\n        DebugPrint_Samsara GetThreadInfo(12)\n        Dim msg as String\n        msg = Chr(10) &amp; Chr(9) &amp; getMeTypeForDebug() &amp; \"Cannot deserialize: \" &amp; Error() &amp; \" on line \" &amp;Erl\n        Error 1500, msg\n    Finally\n        Call Me.cleanup()\n    End Try\nEnd Sub\n</code></pre> <p>On line 8, you put the holder contents - the object you're writing to - in the global variable <code>samsaraObj</code>. </p> <p>On line 10, you extract the ISO date-time into a temporary variable <code>dateTime</code>. Then on lines 11 and 12, you extract the date portion and split it into an array with three elements - year, month, day. You also extract the time portion on line 13.</p> <p>Finally on line 17, you build the string to create and write the date variants. <code>DateNumber()</code> allows us to pass year, month, and day in that order. These are expected as numbers, so you just add the variables to the string. At the point <code>execString</code> is <code>samsaraObj.startDate = DateNumber(2022,06,03)</code>.</p> <p>On line 18, you use <code>CDat()</code> for the time portion. This function takes a string, so you need to add explicitly string delimiters into <code>execString</code>. This string will become <code>samsaraObj.startTime = CDat(\"10:10:30\")</code>.</p> <p>In the final block on line 28, you call <code>Me.cleanup()</code> to clear the global variables.</p> <p>Example code</p>"},{"location":"howto/deserialization/helper.html","title":"Convert JSON to an object","text":""},{"location":"howto/deserialization/helper.html#converting-a-string-to-an-object","title":"Converting a string to an object","text":"<p>Imagine the following class:</p> <pre><code>Class Person\n    Public firstName as String\n    Public lastName as String\n    Public age as Integer\nEnd Class\n</code></pre> <p>You have a JSON string <code>{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42}</code> that you want to parse into a Person object. You can do this with:</p> <pre><code>Dim json as String\nDim helper as New JsonConversionHelper()\nDim jd as Person\n\njson = |{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42}|\nSet jd = helper.fromJsonString(json, \"Person\", \"deser-10\")\n</code></pre>"},{"location":"howto/deserialization/helper.html#converting-a-string-to-an-array-of-objects","title":"Converting a string to an array of objects","text":"<p>If you have the same class but want to process a JSON string <code>[{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42},{\"firstName\":\"Jane\",\"lastName\":\"Doe\",\"age\":30}]</code>, we can do it with very similar code:</p> <pre><code>Dim json as String\nDim helper as New JsonConversionHelper()\nDim jd as Variant\n\njson = |[{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42},{\"firstName\":\"Jane\",\"lastName\":\"Doe\",\"age\":30}]|\njd = helper.fromJsonString(json, \"Person\", \"deser-10\")\n</code></pre> <p>The first difference is you are returning a Variant instead of a Person. As a result, you don't need <code>Set</code> in the last line.</p>"},{"location":"howto/deserialization/helper.html#converting-a-json-object-to-an-object","title":"Converting a JSON object to an object","text":"<p>If you need to manipulate the content, to extract a JSON object from the string and pass that to the helper, then we need different code. Imagine the following JSON <code>{\"success\": true, \"data\": {\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42}}</code>. The JSON object you need to use is stored in the \"data\" element. The code you need is this:</p> <pre><code>Dim parser as New JsonParser()\nDim json as String\nDim obj as JsonObject\nDim helper as New JsonConversionHelper()\nDim jd as Variant\n\njson = |{\"success\": true, \"data\": {\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42}}|\nCall parser.loadFromJson(json)\nSet obj = parser.getRootobject().getChild(\"data\")\nSet jd = helper.toObject(obj, \"Person\", \"deser-10\").fromJson(obj)\n</code></pre> <p>Another option is to convert the JSON object back to a String, in which case this would also work: <code>Set jd = helper.fromJsonString(obj.toString(true), \"Person\", \"deser-10\")</code>.</p>"},{"location":"howto/deserialization/helper.html#converting-a-json-array-to-an-object","title":"Converting a JSON array to an object","text":"<p>Imagine the JSON to parse was <code>{\"success\": true, \"data\": [{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42},{\"firstName\":\"Jane\",\"lastName\":\"Doe\",\"age\":30}]}</code>. The code you need is this:</p> <pre><code>Dim parser as New JsonParser()\nDim json as String\nDim obj as JsonObject\nDim helper as New JsonConversionHelper()\nDim jd as Variant\n\njson = |{\"success\": true, \"data\": [{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42},{\"firstName\":\"Jane\",\"lastName\":\"Doe\",\"age\":30}]}|\nCall parser.loadFromJson(json)\nSet obj = parser.getRootobject().getChild(\"data\")\njd = helper.jsonArrayToObjects(obj, \"Person\", \"deser-10\")\n</code></pre> <p>As before, we could convert the JSON object back to a String, in which case this would also work: <code>jd = helper.fromJsonString(obj.toString(true), \"Person\", \"deser-10\")</code>.</p>"},{"location":"howto/deserialization/helper.html#custom-fromjson-sub","title":"Custom fromJson() sub","text":"<p>If your class has its own <code>fromJson()</code> Sub that takes a JsonObject, this will be called in preference to manually deserializing the JSON. This is an example of a custom sub:</p> <pre><code>Class CustomPerson\n\n    Public firstName as String\n    Public lastName as String\n    Public generatedFromJson as Boolean\n\n    Function fromJson(source as JsonObject) as Variant\n        Me.firstName = source.getChild(\"firstName\").scalarValue\n        Me.lastName = source.getChild(\"lastName\").scalarValue\n        Me.generatedFromJson = true\n        Set fromJson = Me\n    End Function\n\nEnd Class\n</code></pre> <p>This can then be used with the following code:</p> <pre><code>Dim json as String\nDim helper as New JsonConversionHelper()\nDim jd as CustomPerson\n\njson = |{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42}|\nSet jd = helper.fromJsonString(json, \"CustomPerson\", \"deser-10\")\nPrint jd.firstName &amp; \" \" &amp; jd.lastName &amp; \" - generated: \" &amp; jd.generatedFromJson\n</code></pre> <p><code>age</code> will be ignored by the custom function and instead <code>generatedFromJson</code> will be set to true.</p> <p>If the function throws an error, the normal deserialization will be run. If the function runs to completion either successfully or handling the error internally, normal deserialization won't be attempted and the object will be returned. So if an error could be thrown, the JsonConversionHelper will need to be set up with appropriate converters.</p> <p>This approach can be used for deserializing a single object or an array of objects. If serializing an array, the custom <code>fromJson()</code> function will be run and the resulting complete object added to the Variant array.</p> <p>Example code</p>"},{"location":"howto/deserialization/merge.html","title":"Merge into existing VoltScript object","text":"<p>There may be occasions where you use VoltScript JSON Converter to create an object from one JSON object, but then you need to merge in elements from another. For example, imagine you have a feed of pets with IDs of the owner, and you need to merge in the owner information for each pet, like this:</p> <pre><code>    petsJson = |[{\"name\":\"Captain\",\"type\":\"Gentoo Penguin\",\"ownerId\":1},{\"name\":\"Loudy\",\"type\":\"Gentoo Penguin\",\"ownerId\":1},{\"name\":\"Nimrod\",\"type\":\"Gentoo Penguin\",\"ownerId\":1}]|\n    ownerJson = |{\"firstName\":\"Tom\",\"lastName\":\"Popper\"}|\n</code></pre> <p>The <code>withObject()</code> method allows you to handle this. You initially load the petsJson into a Variant array of Pet objects, like so:</p> <pre><code>Dim helper as new JsonConversionHelper()\nDim pets as Variant\npets = helper.fromJsonString(petsJson, \"Pet\", \"deser-90.txt\")\n</code></pre> <p>You need to iterate the Variant array, and then pass in each Pet to the <code>withObject()</code> method, calling <code>fromJson()</code>, passing in a JSON object.</p> <pre><code>Dim ownerObj as JsonObject\nDim parser as New JsonParser()\nDim firstNameConverter as New JsonScalarConverter\nDim lastNameConverter as New JsonScalarConverter\n\nCall parser.loadFromJson(ownerJson)\nSet ownerObj = parser.getRootObject\nFor i = 0 to UBound(pets)\n    Call helper.withObject(pets(i))._\n        withCustomConverter(\"firstName\", firstNameConverter.forPropertyName(\"ownerFirstName\"))._\n        withCustomConverter(\"lastName\", lastNameConverter.forPropertyName(\"ownerLastName\"))._\n        fromJson(ownerObj)\nNext\n</code></pre> <p>Important</p> <ul> <li>You have to use the <code>fromJson()</code> method to load the content. <code>fromJsonString()</code> can't be used with <code>withObject()</code>. So you will need to convert a JSON string into a JSON object before using it.</li> <li>In this scenario, the helper object didn't have any custom converters or label-ignores added when parsing the pets. If it had, the safest approach would have been to re-initialize the helper object before the <code>for</code> loop.</li> <li>In rare cases, you may be able to just re-use a helper without needing to call <code>withObject</code>. But this only works if you're wanting to add to the last object the helper processed.</li> </ul> <p>Example code</p>"},{"location":"howto/deserialization/setter-converter.html","title":"Use and extend JsonSetterConverters","text":""},{"location":"howto/deserialization/setter-converter.html#using-the-jsonsetterconverter","title":"Using the JsonSetterConverter","text":"<p>Imagine you have the following JSON <code>[{\"firstname\": \"Guglielmo\", \"surname\": \"Marconi\", \"share\": \"2\"},{\"firstname\": \"Ferdinand\", \"surname\": \"Braun\", \"share\": \"2\"}]</code> to pass into the following class:</p> <pre><code>Class Laureate\n    Public name as String\n    Public share as String\n\n    Sub setName(firstName as String, lastName as String)\n        Me.name = firstName &amp; \" \" &amp; lastName\n    End Sub\nEnd Class\n</code></pre> <p>The <code>firstname</code> and <code>surname</code> elements in the JSON object need passing to the <code>setName()</code> sub in the class. You need to use a JsonSetterConverter for the name. This can be done with the following code.</p> <pre><code>Dim setterConverter as New JsonSetterConverter()\nCall setterConverter.forSetter(\"setName\")._\n    withValueParam()._\n    withSiblingParam(\"surname\", \"\")\n</code></pre> <p>First, you instantiate the JsonSetterConverter. On the next line, you map it to the <code>setName()</code> function. Then you need to tell it how to find the parameters. The first parameter is the \"firstname\" element in the JSON. You will bind the JsonSetterConverter to this JSON element, so you need to pass the element's value with <code>withValueParam()</code>. The second parameter is the \"surname\" element adjacent to <code>firstname</code>, so you use <code>withSiblingParam()</code> to pull in that element's value, with a default value of <code>\"\"</code>.</p> <p>You then need to pass the converter to the helper.</p> <pre><code>Dim helper as new JsonConversionHelper()\nCall helper.withCustomConverter(\"firstname\", setterConverter)\n</code></pre> <p>You also need to ignore the \"surname\" label, because you are handling it in the jsonSetterConverter. This can be done in two ways, calling <code>helper.ignoreLabel(\"surname\")</code> or suppressing errors with <code>helper.suppressErrors = True</code>.</p> <p>Finally, run the conversion.</p> <pre><code>Dim laureates as Variant\nlaureates = helper.fromJsonString(json, \"Laureate\", \"deser-30\")\n</code></pre> <p>Example code</p>"},{"location":"howto/deserialization/setter-converter.html#creating-a-custom-jsonsetterconverter","title":"Creating a custom JsonSetterConverter","text":"<p>Imagine you have the following JSON <code>{\"enable\":1, \"timestamp\": 1564741004, \"meterLocation\": 0}</code> to pass into the following class:</p> <pre><code>Class HomeData\n    Public timestamp as Double\n    Private enabled as Boolean\n    Public meterLocation as Integer\n\n    Sub enable()\n        Me.enabled = True\n    End Sub\n\n    Sub disable()\n        Me.enabled = False\n    End Sub\n\n    Function isEnabled() as Boolean\n        isEnabled = Me.enabled\n    End Function\nEnd Class\n</code></pre> <p>The enabled property in the class is private, so you can't just pass it into the object. Instead, call either <code>HomeData.enable()</code> or <code>HomeData.disable()</code>. You need to use a custom JsonSetterConverter to define the method to call, depending on the <code>enabled</code> property. This can be done with the following code.</p> <pre><code>Class HomeDataSetterConverter as JsonSetterConverter\n    Sub loadParamValuesFromJsonObject(source as JsonObject, converters List as AbstractJsonConverter)\n        If (source.scalarValue = 1) Then\n            Me.forSetter(\"enable\")\n        Else\n            Me.forSetter(\"disable\")\n        End If\n    End Sub\nEnd Class\n</code></pre> <p>You extend the <code>loadParamValuesFromJsonObject()</code> function using the same signature. You are processing the \"enabled\" property of the JSON object, so in line 3, you check the scalar value. If it's <code>1</code>, you want to run the setter <code>enable()</code> so you pass that setter name to the <code>forSetter()</code> function. Otherwise, run <code>disable()</code> so you pass that setter name to the <code>forSetter()</code> function.</p> <p>You then need to pass the converter to the helper.</p> <pre><code>Dim dataConverter as new HomeDataSetterConverter\nCall helper.withCustomConverter(\"enable\", dataConverter.forSetter(\"enable\"))\n</code></pre> <p>In line 2, you need to pass something as a default argument for <code>dataConverter.forSetter</code>, even though the code overrides it, otherwise the <code>deserialize()</code> function will error. So you pass \"enable\" as the default.</p> <p>Tip</p> <p>When parameters are extracted for custom constructors or custom setters, we cannot identify the data type the method signature expects. When adding the parameter to the custom constructor or custom setter, you can define the default value to use if the JSON object doesn't have that label. But it's not possible to identify the datatype of the variable declaration for the default value - a String is a String, whether it's stored in a String variable or Variant variable. And there are valid use cases where method signatures should accept a Variant of differing datatypes.</p> <p>So if a JSON object contains a value for a specific label, it will just be passed as-is to the custom constructor or custom setter. It is the developer's responsibility to ensure the JSON value is of a valid datatype, or return the error message and require the user to fix up the data.</p> <p>Best practice is to validate the JSON object before using VoltScript JSON Converter. You can see that paradigm in practice in <code>loadLogWritersFromJson()</code>, which calls <code>validateWriterJson()</code> to validate each LogWriter JSON object. The same approach is also done in VoltScript's dependency management, in <code>archipelago_functions.vss</code>.</p> <p>Example code</p>"},{"location":"howto/serialization/index.html","title":"Serialization","text":"<p>Serialization is converting a VoltScript object or array of VoltScript objects to a JSON object or string of JSON.</p> <ul> <li>Convert an Object to JSON</li> <li>Use the JsonArrayConverter</li> <li>Use Object and Object Array Converters</li> <li>Create a custom Converter</li> <li>Use JsonGetterConverters</li> </ul>"},{"location":"howto/serialization/basic-object-converter.html","title":"Use object and object array converters","text":""},{"location":"howto/serialization/basic-object-converter.html#deserializing-inner-objects-with-a-custom-converter","title":"Deserializing inner objects with a custom converter","text":"<p>Imagine the following classes:</p> <pre><code>Class Person\n\n    Public firstName as String\n    Public lastName as String\n    Public pet as Pet\n\nEnd Class\n\nClass Pet\n\n    Public name as String\n    Public type as String\n\nEnd Class\n</code></pre> <p>When deserializing, you were able to just pass a JsonBasicObjectConverter, telling it the class to return and the script location. But when serializing, you need to use a helper that defines which properties of the class to serialize. This could be done with a custom converter and its <code>toJson()</code> function. The converter would be:</p> <pre><code>Class PetConverter as AbstractJsonConverter\n\n    Function toJson(source as Variant) as Variant\n        Dim helper as New JsonConversionHelper()\n        Dim jsonObj as JsonObject\n        Set jsonObj = helper.withScalarConverter(\"name\")._\n            withScalarConverter(\"type\")._\n            toJson(source)\n        Set toJson = jsonObj\n    End Function\n\nEnd Class\n</code></pre> <p>The <code>source</code> object passed into the <code>toJson()</code> function at line 3 will be the Pet object. This creates a <code>JsonConversionHelper</code>, telling it to convert \"name\" and \"type\" as scalars (lines 6 and 7), and calls the helper's own <code>toJson()</code> function on line 8 to return the Pet as a JsonObject. The resulting JsonObject is just returned as the output for the function.</p> <p>This can be used with the following code:</p> <pre><code>Dim helper as New JsonConversionHelper\nDim petConverter as New PetConverter\nCall helper.withScalarConverter(\"firstName\")._\n    withScalarConverter(\"lastName\")._\n    withCustomConverter(\"pet\", petConverter)\n\nDim jsonObj as JsonObject\nSet jsonObj = helper.toJson(person)\n</code></pre> <p>A <code>JsonConversionHelper</code> is created to serialize the Person on line 1. One line 2 an instance of the <code>PetConverter</code> class is created. And the helper is loaded with <code>JsonScalarConverters</code> for \"firstName\" and \"lastName\" and the <code>PetConverter</code> for \"pet\" on lines 3 to 5. Then the person is serialized into a JsonObject on line 8.</p>"},{"location":"howto/serialization/basic-object-converter.html#using-a-jsonbasicobjectconverter","title":"Using a JsonBasicObjectConverter","text":"<p>However, it's possible to serialize the Pet using a <code>JsonBasicObjectConverter</code>. But, just as you did for the custom converter, it needs to be loaded with its own <code>JsonConversionHelper</code> with information of which properties to serialize.</p> <pre><code>Dim petHelper as New JsonConversionHelper\nDim petConverter as New JsonBasicObjectConverter(\"Pet\", \"ser-30\")\nDim helper as New JsonConversionHelper\nDim jsonObj as JsonObject\n\nSet jsonObj = helper.withScalarConverter(\"firstName\")._\n    withScalarConverter(\"lastName\")._\n    withCustomConverter(\"pet\", petConverter._\n        withHelper(petHelper._\n            withScalarConverter(\"name\")._\n            withScalarConverter(\"type\")))._\n    .toJson(person)\n</code></pre> <p>First, you instantiate the variables:</p> <ul> <li>A <code>JsonConversionHelper</code> is created to serialize the pet on line 1.</li> <li>A <code>JsonBasicObjectConverter</code> is created to convert the Pet on line 2.</li> <li>A <code>JsonConversionHelper</code> is created to process everything on line 3.</li> <li>A <code>JsonObject</code> is declared for the result on line 4.</li> </ul> <p>Then you're ready to get your JsonObject. The main helper is loaded with <code>JsonScalarConverters</code> for \"firstName\" (line 6) and \"lastName\" (line 7) and the <code>JsonBasicObjectConverter</code>, <code>petConverter</code> (line 8). On line 9 the <code>petConverter</code> is loaded with its own helper, <code>petHelper</code>, which needs different converters to the main helper. The <code>petHelper</code> is loaded with two <code>JsonScalarConverters</code> for \"name\" (line 10) and \"type\" (line 11). And Finally, the main helper's <code>toJson()</code> function is called on line 12, passing the Person you wish to deserialize.</p>"},{"location":"howto/serialization/basic-object-converter.html#manual-conversion","title":"Manual conversion","text":"<p>If the Person object holds an array of Pets instead of just one Pet, you can just use the JsonBasicObjectConverter. The code is similar to the code for serializing a single Pet.</p> <pre><code>Dim petHelper as New JsonConversionHelper\nDim petConverter as New JsonBasicObjectArrayConverter(\"Pet\", \"ser-30\")\nDim helper as New JsonConversionHelper\nDim jsonObj as JsonObject\n\nSet jsonObj = helper.withScalarConverter(\"firstName\")._\n    withScalarConverter(\"lastName\")._\n    withCustomConverter(\"pets\", petConverter._\n        withHelper(petHelper._\n            withScalarConverter(\"name\")._\n            withScalarConverter(\"type\")))._\n    toJson(person)\n</code></pre> <p>The only differences are that on line 2, you create <code>petConverter</code> as a <code>JsonBasicObjectArrayConverter</code> instead of a <code>JsonBasicObjectConverter</code>, and you assign the converter to the \"pets\" property and label on line 8.</p> <p>Example code</p>"},{"location":"howto/serialization/custom-converter.html","title":"Create a custom converter","text":""},{"location":"howto/serialization/custom-converter.html#overriding-tojson","title":"Overriding toJson()","text":"<p>Imagine you have a class that has <code>Public modified as Variant</code> where this is a date variant. But you want to output it in JSON as a string of date-time format. This can't be directly serialized to a JsonObject.</p> <p>First, create your custom converter class:</p> <pre><code>Class DateTimeSerializer as AbstractJsonConverter\n\nEnd Class\n</code></pre> <p>For the body of the <code>toJson()</code> function, get the string value from the \"modified\" element and convert it to an ISO date string. So the complete function is:</p> <pre><code>Function toJson(source As Variant) As Variant\n    toJson = Format(source, \"yyyy-mm-ddThh:nn:ssZ\")\nEnd Function\n</code></pre> <p>You can use it with the following code:</p> <pre><code>Dim helper as new JsonConversionHelper\nDim parser as New DateTimeParser\nDim dateConverter as New DateTimeSerializer\nDim obj as New ObjectSummary\nDim jsonObj as JsonObject\n\nobj.unid = \"12345678901234567890123456789012\"\nobj.action = \"created\"\nSet obj.modified = DateNumber(2022,2,2) + TimeNumber(2,2,22)\nCall helper.withCustomConverter(\"modified\", dateConverter)._\n    withScalarConverter(\"action\")._\n    withScalarConverter(\"unid\")\nSet jsonObj = helper.toJson(obj)\n</code></pre>"},{"location":"howto/serialization/custom-converter.html#overriding-serialize","title":"Overriding serialize()","text":"<p>Occasionally, just converting the value won't be enough. You might need to do something more extensive with the value you're deserializing. Imagine the JSON should only include a \"modified\" element if it's been set.</p> <p>First, create your custom converter class:</p> <pre><code>Class DateTimeOrNothingSerializer as AbstractJsonConverter\n\nEnd Class\n</code></pre> <p>You need to override the standard <code>serialize()</code> sub, which needs the same signature as the sub in the base class, so <code>Sub serialize(source As Variant, target as JsonObject)</code>. The <code>labelName</code> parameter will be the label to write to in the JsonObject. <code>source</code> will be the current object, of type ObjectSummary. <code>target</code> will be the JsonObject you're writing to. The code will be:</p> <pre><code>Sub serialize(source As Variant, target as JsonObject)\n    If (Not IsEmpty(source.modified)) Then\n        Call target.insertValue(Me.labelName, Format(source.modified, \"yyyy-mm-ddThh:nn:ssZ\"))\n    End If\nEnd Sub\n</code></pre> <p>If <code>source.modified</code> isn't set, do nothing. Otherwise, convert the value to an ISO date-time string and insert into the JsonObject. If modified is set, you will get:</p> <pre><code>{\n  \"action\": \"created\",\n  \"modified\": \"2022-02-02T02:02:22Z\",\n  \"unid\": \"12345678901234567890123456789012\"\n}\n</code></pre> <p>If not, you will get:</p> <pre><code>{\n  \"action\": \"created\",\n  \"unid\": \"12345678901234567890123456789012\"\n}\n</code></pre> <p>Example code</p>"},{"location":"howto/serialization/getter-converter.html","title":"Use JsonGetterConverters","text":""},{"location":"howto/serialization/getter-converter.html#simple-jsongetterconverter","title":"Simple JsonGetterConverter","text":"<p>The previous examples only address scenarios where the properties in your class map directly to the entities in the JSON you want to output. That's not always the case. You could manually generate the JSON using a <code>toJson()</code> function in your class. Alternatively, if you class has a function that outputs what you need, you can use a JsonGetterConverter. Imagine you have the following class:</p> <pre><code>Class Laureate\n    Public firstName as String\n    Public lastName as String\n    Public share as String\n\n    Function getName() as String\n        getName = firstName &amp; \" \" &amp; lastName\n    End Function\nEnd Class\n</code></pre> <p>Use a JsonGetterConverter to output a name entity. This can be done with the following code.</p> <pre><code>Dim helper as New JsonConversionHelper\nDim jsonObj as JsonObject\nDim nameConverter as New JsonGetterConverter()\nSet jsonObj = helper.withScalarConverter(\"share\")._\n    withCustomConverter(\"name\", nameConverter.forGetter(\"getName\"))._\n    toJson(laureate)\n</code></pre> <p>You instantiate the <code>JsonGetterConverter</code> on line 3. You convert the JsonObject, using a <code>JsonScalarConverter</code> for \"share\" in line 4, and passing the <code>JsonGetterConverter</code> as a custom converter writing to the \"name\" element and for the getter <code>getName</code> in line 5.</p>"},{"location":"howto/serialization/getter-converter.html#passing-parameters-to-getters","title":"Passing parameters to getters","text":"<p>With the custom setters, you had a variety of parameter types that could be passed - the current value, a sibling value or a literal value. With custom getters there is only one parameter type - a literal value. The expectation is that a getter that requires another value from the current VoltScript object should be accessing it directly rather than receiving it as a parameter.</p> <p>Imagine you have the following class:</p> <pre><code>Class Laureate\n    Public firstName as String\n    Public lastName as String\n    Public share as String\n\n    Function getFullName(firstNameFirst as Boolean)\n        If (firstNameFirst) Then\n            getFullName = Me.firstName &amp; \" \" &amp; Me.lastName\n        Else\n            getFullName = Me.lastName &amp; \", \" &amp; Me.firstName\n        End If\n    End Function\nEnd Class\n</code></pre> <p>You need to use a JsonGetterConverter to output the full name, passing a parameter. This can be done with the following code:</p> <pre><code>    Dim helper as New JsonConversionHelper\n    Dim jsonObj as JsonObject\n    Dim nameConverter as New JsonGetterConverter()\n    Set jsonObj = helper.withScalarConverter(\"share\")._\n        withCustomConverter(\"name\", nameConverter._\n            forGetter(\"getFullName\")._\n            withLiteralParam(true))._\n        toJson(laureate)\n</code></pre> <p>Example code</p>"},{"location":"howto/serialization/helper.html","title":"Convert an object to JSON","text":""},{"location":"howto/serialization/helper.html#converting-an-object-to-a-string","title":"Converting an object to a string","text":"<p>Imagine the following class:</p> <pre><code>Class Person\n    Public firstName as String\n    Public lastName as String\n    Public age as Integer\nEnd Class\n</code></pre> <p>You want to return the JSON as a non-prettified JSON String, so you call <code>toJsonString()</code> passing the Person object and <code>false</code> as the second parameter on line 11.</p> <pre><code>Dim json as String\nDim helper as New JsonConversionHelper()\nDim jd as New Person()\n\njd.firstName = \"John\"\njd.lastName = \"Doe\"\njd.age = 42\njson = helper.withScalarConverter(\"firstName\")._\n    withScalarConverter(\"lastName\")._\n    withScalarConverter(\"age\")._\n    toJsonString(jd, false)\n</code></pre> <p>This returns <code>{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42}</code>.</p> <p>The same syntax can be used to convert an object or an array of objects.</p>"},{"location":"howto/serialization/helper.html#converting-an-object-to-a-jsonobject","title":"Converting an object to a JsonObject","text":"<p>With the same class, if you want to return a JsonObject instead of the string of JSON, you would instead use:</p> <pre><code>Dim jsonObj as JsonObject\nDim helper as New JsonConversionHelper()\nDim jd as New Person()\n\njd.firstName = \"John\"\njd.lastName = \"Doe\"\njd.age = 42\nSet jsonObj = helper.withScalarConverter(\"firstName\")._\n    withScalarConverter(\"lastName\")._\n    withScalarConverter(\"age\")._\n    toJson(jd)\n</code></pre>"},{"location":"howto/serialization/helper.html#converting-an-array-of-objects","title":"Converting an array of objects","text":"<p>If you have the same class but want to process multiple objects, you can do it with a similar code:</p> <pre><code>Dim json as String\nDim helper as New JsonConversionHelper()\nDim jd(1) as Person\n\nSet jd(0) = New Person()\njd(0).firstName = \"John\"\njd(0).lastName = \"Doe\"\njd(0).age = 42\nSet jd(1) = New Person()\njd(1).firstName = \"Jane\"\njd(1).lastName = \"Doe\"\njd(1).age = 30\njson = helper.withScalarConverter(\"firstName\")._\n    withScalarConverter(\"lastName\")._\n    withScalarConverter(\"age\")._\n    toJsonString(jd, true)\n</code></pre> <p>You could pass in a Person array, as here, or a Variant containing the Person array. If you wanted a JsonObject, you would just call <code>helper.toJson(jd)</code> on line 16. But this code returns a prettified JSON string:</p> <pre><code>[\n    {\n        \"firstName\": \"John\",\n        \"lastName\": \"Doe\",\n        \"age\": 42\n    },\n    {\n        \"firstName\": \"Jane\",\n        \"lastName\": \"Doe\",\n        \"age\": 30\n    }\n]\n</code></pre>"},{"location":"howto/serialization/helper.html#using-provided-converters-for-different-properties","title":"Using provided converters for different properties","text":"<p>As with deserialization, it's possible to serialize from one property name and write to a different label in the JSON. In this case, you need to pass the <code>JsonScalarConverter</code> as a JsonCustomConverter. If you want to get the <code>lastName</code> property and write it to a <code>surname</code> element in the JSON, the code would be:</p> <pre><code>Dim surnameConverter as New JsonScalarConverter\nSet jsonObj = helper.withScalarConverter(\"firstName\")._\n    withCustomConverter(\"surname\", surnameConverter.forPropertyName(\"lastName\"))._\n    withScalarConverter(\"age\")._\n    toJson(jd)\n</code></pre> <p>You declare a JsonScalarConverter as <code>surnameConverter</code> in line 1, and then pass it to the helper for the property name \"lastName\" in line 3 to write to the label \"surname\".</p>"},{"location":"howto/serialization/helper.html#custom-tojson-function","title":"Custom toJson() function","text":"<p>If your class has its own <code>toJson()</code> function that returns a JsonObject, this will be called in preference to manually serializing the object. This is an example of a custom function</p> <pre><code>Class CustomPerson\n\n    Public firstName as String\n    Public lastName as String\n\n    Function toJson() as JsonObject\n        Dim resp as New JsonObject()\n        Call resp.insertValue(\"firstName\", Me.firstName)\n        Call resp.insertValue(\"lastName\", Me.lastName)\n        Call resp.insertValue(\"generated\", true)\n        Set toJson = resp\n    End Function\n\nEnd Class\n</code></pre> <p>With a custom serialization function, there is no need to pass any converters to the helper. So the code required will be:</p> <pre><code>    Dim jsonObj as JsonObject\n    Dim helper as New JsonConversionHelper()\n\n    Set jsonObj = helper.toJson(jd)\n</code></pre> <p>If the function throws an error, the normal serialization will be run. If the function runs to completion either successfully or handling the error internally, normal deserialization won't be attempted and the object will be returned. So if an error could be thrown, the JsonConversionHelper will need to be set up with appropriate converters.</p> <p>This approach can be used for serializing a single object or an array of objects. If serializing an array, the custom <code>fromJson()</code> function will be run and the resulting complete object added to the JsonObject array.</p> <p>Example code</p>"},{"location":"howto/serialization/scalar-array-converter.html","title":"Use the JsonArrayConverter","text":""},{"location":"howto/serialization/scalar-array-converter.html#scalar-array-converter","title":"Scalar array converter","text":"<p>Often a class may contain arrays. You saw that with deserialization, a class member variable thats expected to receive an array must be declared as a Variant. This means that it may or may not be an array. Imagine a class with this code:</p> <pre><code>Class Session\n\n    Public id as String\n    Public title as String\n    Public products as Variant\n\nEnd Class\n</code></pre> <p>Assuming that the products variable is only used to hold scalars, such as an array of Strings, you can just use a JsonArrayConverter. So the instance of the class can be created like so:</p> <pre><code>Dim sess as New Session\nsess.id = \"Ad16\"\nsess.title = \"Colaborate around Business Applications in Communities\"\nsess.products = Split(\"Domino,Connections,Volt\", \",\")\n</code></pre> <p>The object can be deserialized by adding a JsonScalarConverter for <code>id</code> and <code>title</code>, and a JsonArrayConverter for <code>products</code>.</p> <pre><code>Call helper.withScalarConverter(\"id\").withScalarConverter(\"title\").withArrayConverter(\"products\")\njson = helper.toJsonString(sess, true)\n</code></pre>"},{"location":"howto/serialization/scalar-array-converter.html#forcing-arrays","title":"Forcing arrays","text":"<p>The <code>JsonArrayConverter</code> will return an array regardless of the source. So even if the instance of the Session class is created like so:</p> <pre><code>sess.id = \"Ad01\"\nsess.title = \"Domino HA\"\nsess.products = \"Domino\"\n</code></pre> <p>The JSON returned will still be an array:</p> <pre><code>{\n  \"id\": \"Ad01\",\n  \"products\": [\n    \"Domino\"\n  ],\n  \"title\": \"Domino HA\"\n}\n</code></pre>"},{"location":"howto/serialization/scalar-array-converter.html#class-with-array-member-variable","title":"Class with array member variable","text":"<p>Currently with VoltScript JSON Converter, member variables like <code>product</code> that are expected to receive arrays need to be declared as Variants. Otherwise a compiler error \"Illegal reference to array or list\" will be thrown when the code to write to the member variable is executed. This also makes it easier to write to the class. If the member variable is declared as <code>Public products() as String</code>, you can no longer just use <code>Split()</code> directly. Instead, you need to split and iterate the result, and then add each element in the array in turn:</p> <pre><code>Dim temp as Variant\nDim i as integer\n\ntemp = Split(\"Domino,Connections,Volt\", \",\")\nRedim sess.products(UBound(temp))\nFor i = 0 to UBound(temp)\n    sess.products(i) = temp(i)\nNext\n</code></pre> <p>Serialization will still work the same though. The helper can still be set up with <code>Call helper.withScalarConverter(\"id\").withScalarConverter(\"title\").withArrayConverter(\"products\")</code>.</p> <p>However, the <code>JsonScalarConverter</code> will also return an array, if the source is an array. So the helper will still have the same result if set up with <code>Call helper.withScalarConverter(\"id\").withScalarConverter(\"title\").withScalarConverter(\"products\")</code>.</p> <p>An array will also be returned if the object is created with the following code:</p> <pre><code>sess.id = \"Ad01\"\nsess.title = \"Domino HA\"\nRedim sess.products(0)\nsess.products(0) = \"Domino\"\n</code></pre> <p>This is because an array check on the <code>products</code> variable will return <code>true</code>, it's an array under all circumstances.</p> <p>Example code</p>"},{"location":"references/index.html","title":"References","text":"<p>References provide technical references and descriptions for VoltScript JSON Converter.</p>"},{"location":"references/index.html#whats-new","title":"What's new","text":"<p>Check the latest information about VoltScript JSON Converter.</p>"},{"location":"references/index.html#repository-structure","title":"Repository structure","text":"<ul> <li>All the code for the framework itself is in <code>VoltScriptJsonConverter.vss</code>.</li> <li>Some tester samples are in the <code>samples</code> directory.</li> <li>A set of unit tests for validating the code is in the <code>unittests</code> directory.</li> <li><code>runAllTests.vss</code> is a script file to verify all tests pass. The output is written to the <code>unit-test-reports</code> directory.</li> </ul>"},{"location":"references/index.html#api-documentation","title":"API documentation","text":"<p>Full API Documentation for VoltScript JSON Converter</p>"},{"location":"references/index.html#examples","title":"Examples","text":"<p>Simple deserialization and serialization examples.</p>"},{"location":"references/index.html#test-reports","title":"Test reports","text":"<ul> <li>Basic Class Conversion</li> <li>Basic Person Class Conversion</li> <li>Basic Person Class Arrays Conversion</li> <li>Class with Arrays Conversion</li> <li>Class with Dates Conversion</li> <li>Class with Dates Arrays Conversion</li> <li>Complex Person Class Conversion</li> <li>Complex Person Class Conversion to Custom Properties</li> <li>Complex Person Class Conversion with Custom Constructor</li> <li>Basic fromJson Function Conversion</li> <li>Person Class with Custom fromJson Function Conversion</li> <li>Basic Object Summary Class Conversion</li> <li>Person Class with Custom Getter Function Conversion</li> <li>Person Class with Custom Setter Function Conversion</li> <li>Error Tests</li> <li>LogWriters Tests</li> </ul>"},{"location":"references/index.html#faqs","title":"FAQs","text":"<p>List of frequently asked questions related to VoltScript JSON Converter.</p>"},{"location":"references/index.html#documentation-and-source-code","title":"Documentation and source code","text":"<ul> <li>HCL Volt MX Go Documentation</li> <li>VoltScript<ul> <li>Documentation</li> </ul> </li> <li>VoltScript Testing<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Collections<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Console Colors<ul> <li>Source code</li> </ul> </li> <li>VoltScript Interface Designer<ul> <li>Documentation</li> </ul> </li> <li>VoltScript Volt MX Middleware<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Logging<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> </ul>"},{"location":"references/index.html#support","title":"Support","text":"<p>To share information, ask questions, and learn about VoltScript JSON Converter, go to the Community.</p>"},{"location":"references/example.html","title":"Deserialization / serialization examples","text":""},{"location":"references/example.html#simple-deserialization-example","title":"Simple deserialization example","text":"<p>Let's assume a basic class for a Person:</p> <pre><code>Class Person\n    Public firstName as String\n    Public lastName as String\n    Public age as Integer\nEnd Class\n</code></pre> <p>A corresponding JSON structure would be:</p> <pre><code>{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42}\n</code></pre> <p>This could be processed with the following VoltScript code:</p> <pre><code>Dim json as String\nDim helper as New JsonConversionHelper()\nDim jd as Person\n\njson = |{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":42}|\nSet jd = helper.fromJsonString(json, \"Person\", \"PersonIndex\")\n</code></pre> <p>For more detailed instructions on deserialization, including using custom converters and constructors, see Deserialization.</p>"},{"location":"references/example.html#simple-serialization-example","title":"Simple serialization example","text":"<p>Using the same Person class, an object could be serialized using the following VoltScript code:</p> <pre><code>Dim helper as New JsonConversionHelper()\nDim jsonObj as JsonObject\n\nCall helper.withScalarConverter(\"firstName\").withScalarConverter(\"lastName\").withScalarConverter(\"age\")\nSet jsonObj = helper.toJson(jd)\n</code></pre> <p>For more detailed instructions on serialization, including using custom converters and constructors, see Serialization.</p>"},{"location":"references/faqs.html","title":"FAQs","text":""},{"location":"references/faqs.html#my-json-is-an-array-of-objects-how-do-i-process-that","title":"My JSON is an array of objects. How do I process that?","text":"<p>If you're processing a string of JSON, VoltScript JSON Converter's <code>fromJsonString()</code> function automatically checks whether the top level is an array and processes it accordingly. Just remember that the response must be put into a Variant because an object array can't be assigned - the array must be iterated and each element set from a corresponding array.</p> <p>If you're starting from a JsonObject of type array, use <code>JsonConversionHelper.jsonArrayToObjects(JsonObject, classNameForEach, libNameForClass)</code>.</p>"},{"location":"references/faqs.html#when-i-use-voltscript-json-converter-to-process-an-array-how-do-i-call-a-function-to-save-each-object-to-a-database","title":"When I use VoltScript JSON Converter to process an array, how do I call a function to save each object to a database?","text":"<p>The framework is designed to convert to VoltScript objects, not to process those objects. You should convert the array of JSON objects, then iterate them in post-processing to perform your save.</p> <p>Alternatively, you can parse the JSON array and use a For loop to iterate its children. Then use VoltScript JSON Converter to convert each child JSON object to a VoltScript object and call your function, before moving onto the next child.</p>"},{"location":"references/faqs.html#how-do-i-pass-the-parent-object-as-a-property-of-a-child","title":"How do I pass the parent object as a property of a child?","text":"<p>VoltScript JSON Converter is designed to convert JSON objects using the hierarchy of JSON passed in. Therefore children can be properties of a parent, but not vice versa. If you wish a different class hierarchy to the JSON hierarchy, there are some options:</p> <ul> <li>Parse both as normal. Then, from the parent, create a reverse linkage back to the child.</li> <li>Parse and return the parent object, skipping the property that contains its child / children. Then use a separate helper to parse and return the child. Finally pass the parent to the child's property.</li> <li>If the child requires the parent as a parameter of the constructor, parse and return the parent object, skipping the property that contains its child / children. Then create the constructor, passing the relevant parameters, including a literal parameter containing the parent. Now use a separate helper to parse and return the child.</li> </ul>"},{"location":"references/faqs.html#the-json-i-receive-may-not-be-valid","title":"The JSON I receive may not be valid","text":"<p>Best practice is to use VoltScript Testing Framework to perform unit tests on the JSON and validate it before passing to VoltScript JSON Converter. You can see that paradigm in practice in <code>loadLogWritersFromJson()</code>, which calls <code>validateWriterJson()</code> to validate each LogWriter JSON object. The same approach is also done in VoltScript's dependency management, in <code>archipelago_functions.vss</code>.</p>"},{"location":"references/logwriters.html","title":"Loading LogWriters from JSON","text":""},{"location":"references/logwriters.html#detailed-description","title":"Detailed description","text":"<p>The detailed description of the schema for each LogWriter is:</p> <p>|Property|Required|Description| |:-------||:-----:|:----------| |writerClass|\u2713|VoltScript class to use for the LogWriter| |writerFilePath|\u2713|the path relative to the project for finding the LogWriter class| |constructorArgs|\u2713|an object of key/value pairs mapping to arguments in the constructor| |constructorOrder|\u2713|an array of <code>constructorArgs</code> keys defining the order they should be passed to the constructor of the <code>writerClass</code>|</p> <p>Tip</p> <p>A JSON object is an unordered set of name/value pairs, so the <code>constructorOrder</code> property is used to enforce a consistent ordering when passing to the VoltScript class constructor.</p>"},{"location":"references/logwriters.html#validation","title":"Validation","text":"<p>If you're writing the LogWriter configuration file in Visual Studio Code, the \"VoltScript Build Manager\" extension will validate the JSON as you enter it.</p> <p>In addition, the <code>loadLogWritersFromJson()</code> function will validate each LogWriter JSON object before loading it. You can review the tests it uses by looking at the private function <code>validateWriterJson()</code> in VoltScriptJsonConverter.vss.</p>"},{"location":"references/whatsnew.html","title":"What's new","text":"<p>The section provides information on the latest features, improvements, and resolved issues related to VoltScript JSON Converter.</p> <p>Important</p> <ul> <li>Items marked in red are API changes that may impact your applications and should be reviewed before upgrading.</li> </ul> v1.0.5 - What's new or changed v1.0.4 - What's new or changed v1.0.3 - What's new or changed v1.0.2 - What's new or changed v1.0.1 - What's new or changed v1.0.0 - What's new or changed"},{"location":"references/whatsnew.html#v-105","title":"v 1.0.5","text":"<p>Improvements</p> <ul> <li>Repointing atlas.json TO demo marketplace. atlas-settings marketplace url will need updating to \"https://accounts.auth.demo-hclvoltmx.net/login\"</li> <li>Add function to load LogWriters from a file.</li> <li>Add VoltScriptLogging to VoltScript JSON Converter and documentation.</li> <li>Changed <code>failSilently()</code> function to <code>suppressErrors()</code> boolean property, for consistency with VoltScript Collections.</li> <li>API Docs updated.</li> <li>Documentation on using VoltScript Testing Framework to validate before conversion.</li> </ul>"},{"location":"references/whatsnew.html#v104","title":"v1.0.4","text":"<p>Improvements</p> <ul> <li>Repointing atlas.json to use VSE title and filename as library and module.</li> </ul>"},{"location":"references/whatsnew.html#v103","title":"v1.0.3","text":"<p>Improvements</p> <ul> <li>Added VSID database to repo</li> <li>Repointing atlas.json from demo marketplace. atlas-settings marketplace url will need updating to \"https://accounts.auth.hclvoltmx.net/login\"</li> </ul>"},{"location":"references/whatsnew.html#v102","title":"v1.0.2","text":"<p>Resolved Issues</p> <ul> <li>Fixed JsonArrayConverter to return JSON array instead of JSON object for empty Variants</li> <li>Moved voltscript-testing to test dependency</li> </ul>"},{"location":"references/whatsnew.html#v101","title":"v1.0.1","text":"<p>Improvements</p> <ul> <li>Updated API doc from VoltScript Interface Designer.</li> <li>Code merged with skeletons auto-generated from VoltScript Interface Designer.</li> </ul>"},{"location":"references/whatsnew.html#v100","title":"v1.0.0","text":"<ul> <li>First release version of VoltScript JSON Converter.</li> </ul>"},{"location":"topicguides/index.html","title":"Topic guides","text":"<p>Topic guides discuss and explain topics and concepts about VoltScript JSON Converter.</p> <ul> <li>Aims for the framework</li> <li>How it works</li> <li>Custom Converters and Constructors</li> </ul>"},{"location":"topicguides/aims.html","title":"Aims for the framework","text":"<ul> <li>Minimize the code required to consume JSON as much as possible.</li> <li>Avoid the need for non-standard quirks in VoltScript Classes.</li> <li>Encourage the use of VoltScript Classes when integrating with REST services.</li> <li>Provide intuitive coding structures.</li> <li>Provide a pleasurable coding experience.</li> </ul> <p>Like frameworks in other languages, the framework is designed only to speed up conversion from JSON to VoltScript objects, so that they can subsequently be processed as VoltScript objects. The framework isn't designed to enable you to complete all your custom processing directly from the JSON objects. To do so would overcomplicate the framework.</p> <p>The framework can be used to create relationships, but only uni-directionally, like in the corresponding JSON. The framework can use JSON in the format <code>{\"firstName\":\"Ron\",\"lastName\":\"Burgundy\",\"pet\": {\"name\":\"Baxter\",\"type\":\"Dog\"}}</code> to define a <code>pet</code> property in a Person object, but not an <code>owner</code> property in the Pet object. That should be done as part of your subsequent processing.</p> <p>The framework does not attempt to validate the JSON before processing. With a language that supports reflection, that's easier because it's possible to interrogate the method signatures. With VoltScript, that's not possible. So the best practice approach - and one we have used internally on multiple occasions - is to use VoltScript Testing Framework to perform the validation, then VoltScript JSON Converter to perform the conversion.</p>"},{"location":"topicguides/approach.html","title":"How it works","text":"<p>As a compiled language, VoltScript can't leverage reflection to convert the data. However, the <code>Execute</code> function in VoltScript can be leveraged with global variables. A string can be built for the code that needs to be run, and <code>Execute</code> can perform that code.</p> <p>This covers the basics of converting strings, numbers, and arrays of strings or numbers. But the framework also provides functionality for more sophisticated deserialization scenarios:</p> <ul> <li>Classes that require a custom constructor.</li> <li>Custom converters to convert to / from specific data types.</li> <li>Custom converters that require different property names to JSON labels.</li> <li>Custom converters that need to call subs or functions instead of writing directly to properties.</li> <li>Ignoring specific labels in the JSON.</li> </ul>"},{"location":"topicguides/approach.html#entrypoint","title":"Entrypoint","text":"<p>The JsonConversionHelper is the object to use for converting from JSON. The Helper can contain:</p> <ul> <li>A JsonConstructor from which to create the top-level object (if parsing a single JSON object) or objects (if parsing an array of objects).</li> <li>An array of JsonConverters for custom deserialization of elements from the JSON.</li> <li>An array of labels to ignore from the JSON.</li> </ul> <p>For deserialization, the labels in the JSON object are iterated. But for serialization, VoltScript can't use reflection to know the properties available. So converters must be passed and mapped to properties or functions. More details are in the How To Guides.</p>"},{"location":"topicguides/approach.html#classes-with-fromjson-tojson-function","title":"Classes with fromJson / toJson function","text":"<p>If a class has a <code>fromJson()</code> or a <code>toJson()</code> function with the correct signature, this will be used instead of iterating elements within the JSON. More details are in the How-to guides.</p> <p>Tip</p> <p>When parameters are extracted for custom constructors or custom setters, we cannot identify the data type the method signature expects. When adding the parameter to the custom constructor or custom setter, you can define the default value to use if the JSON object doesn't have that label. But it's not possible to identify the datatype of the variable declaration for the default value - a String is a String, whether it's stored in a String variable or Variant variable. And there are valid use cases where method signatures should accept a Variant of differing datatypes.</p> <p>So if a JSON object contains a value for a specific label, it will just be passed as-is to the custom constructor or custom setter. It is the developer's responsibility to ensure the JSON value is of a valid datatype, or return the error message and require the user to fix up the data.</p> <p>Best practice is to validate the JSON object before using VoltScript JSON Converter. You can see that paradigm in practice in <code>loadLogWritersFromJson()</code>, which calls <code>validateWriterJson()</code> to validate each LogWriter JSON object. The same approach is also done in VoltScript's dependency management, in <code>archipelago_functions.vss</code>.</p>"},{"location":"topicguides/custom.html","title":"Custom converters and constructors","text":""},{"location":"topicguides/custom.html#pre-packaged-custom-converters","title":"Pre-packaged custom converters","text":"<p>The following custom converters are available out-of-the-box:</p> <ul> <li>JsonScalarConverter is automatically used by the JsonConversionHelper to convert strings or numbers.</li> <li>JsonArrayConverter is automatically used by the JsonConversionHelper to convert arrays. This can contain its own converter, to define how to serialize each element of the array.</li> <li>JsonBasicObjectConverter is used to convert a nested JSON object. The constructor takes two parameters, <code>className</code> for the object type to return and <code>libName</code> for the script file that contains the class. It can take its own JsonConversionHelper to define how to convert elements in the JSON object.</li> <li>JsonBasicObjectArrayConverter is used to convert an array of values that are JSON objects. It works the same as the JsonBasicObjectConverter.</li> <li> <p>JsonSetterConverter is used to call a custom setter function in the relevant object while it's being converted from JSON. This can only be used for deserialization. The setter function will require parameters, so three function are available to pass parameters from different sources:</p> <ul> <li>withValueParam is used to pass the scalar value in the JSON element with which the converter is associated.</li> <li> <p>withSiblingParam is used to pass the scalar value of a JSON element at the same level as the one with which the converter is associated. A default value is required and this will be used if the JSON element doesn't exist.</p> <p>Note</p> <p>If the JSON element exists its value will be passed, even if it's an empty string or empty array. A custom converter will be used, if it matches.</p> </li> <li> <p>withLiteralParam is used to pass a literal value.</p> </li> </ul> </li> <li> <p>JsonGetterConverter is used to call a custom function in the relevant object to return a JSON value. This can only be used for serialization. The return value will be inserted, without additional conversion, into the JSON object. As a result, it can only be used if the function returns a scalar value (string, number, string of type date etc). The getter may require additional parameters. If so, two functions are available to pass parameters from different sources:</p> <ul> <li>withPropertyParam is used to pass a value from the object with which the converter is associated.</li> <li>withLiteralParam is used to pass a literal value.</li> </ul> </li> </ul>"},{"location":"topicguides/custom.html#custom-converters-and-constructors_1","title":"Custom converters and constructors","text":"<p>There will be scenarios where custom converters and constructors need to be written. The framework supports this. For more details, see the How-to section.</p> <p>Tip</p> <p>When parameters are extracted for custom constructors or custom setters, we cannot identify the data type the method signature expects. When adding the parameter to the custom constructor or custom setter, you can define the default value to use if the JSON object doesn't have that label. But it's not possible to identify the datatype of the variable declaration for the default value - a String is a String, whether it's stored in a String variable or Variant variable. And there are valid use cases where method signatures should accept a Variant of differing datatypes.</p> <p>So if a JSON object contains a value for a specific label, it will just be passed as-is to the custom constructor or custom setter. It is the developer's responsibility to ensure the JSON value is of a valid datatype, or return the error message and require the user to fix up the data.</p> <p>Best practice is to validate the JSON object before using VoltScript JSON Converter. You can see that paradigm in practice in <code>loadLogWritersFromJson()</code>, which calls <code>validateWriterJson()</code> to validate each LogWriter JSON object. The same approach is also done in VoltScript's dependency management, in <code>archipelago_functions.vss</code>.</p>"},{"location":"tutorial/index.html","title":"Tutorials","text":"<p>Tutorials give hands-on introduction on how to use VoltScript JSON Converter.</p> <ul> <li>Parse a file of Nobel Prize winners</li> <li>Parse a file of CollabSphere Sessions</li> <li>Extend CollabSphere Sessions parsing</li> </ul>"},{"location":"tutorial/collabsphere_1.html","title":"Parsing CollabSphere Sessions","text":""},{"location":"tutorial/collabsphere_1.html#pre-requisites","title":"Pre-Requisites","text":"<ol> <li>Complete Parsing Nobel Laureates</li> </ol>"},{"location":"tutorial/collabsphere_1.html#objectives","title":"Objectives","text":"<ol> <li>Gain experience working with VoltScript in a Visual Studio Code environment.</li> <li>Learn about working with VoltScript Extensions (specifically JsonVSE).</li> <li>Introduce the VoltScript Json Converter Libray</li> <li>Gain familiarity with processing JSON and the use of Custom Converters</li> </ol>"},{"location":"tutorial/collabsphere_1.html#setup-the-project","title":"Setup the project","text":"<ol> <li>Ensure your atlas-settings.json is set up with authentication for Volt MX Marketplace and github.com.</li> <li>Create a folder for the project.</li> <li>Create an atlas.json and complete mandatory elements. Set <code>sourceDir</code> to \"src\", <code>libsDir</code> to \"\"libs\" and <code>vsesDir</code> to \"vses\".</li> <li> <p>In the repositories element, add the following repository:</p> <pre><code>{\n        \"id\": \"hcl-github\",\n        \"type\": \"github\",\n        \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\"\n    }\n</code></pre> </li> <li> <p>In the dependencies element, add the following dependency:</p> <pre><code>        {\n        \"library\": \"voltscript-testing\",\n        \"version\": \"latest\",\n        \"module\": \"VoltScriptTesting.vss\",\n        \"repository\": \"hcl-github\"\n    }\n</code></pre> </li> <li> <p>Save the atlas.json and ensure no validation errors.</p> </li> <li>Run dependency management (Ctrl + Chift + P / Cmd + Shift + P and choose \"VoltScript: Install Dependencies\").</li> <li>Ensure libs contains \"VoltScriptJsonConverter\" and vses contains the JSONVSE extensions.</li> </ol>"},{"location":"tutorial/collabsphere_1.html#get-the-json-file","title":"Get the JSON file","text":"<ol> <li>Access the JSON data from the Collabsphere Website.</li> <li>Download the data and save it to a file called <code>collabsphere.json</code> in the src directory.</li> </ol> <p>Note</p> <p>The \"live\" version of this file is pulled by referencing a JSON agent running on the CollabSphere website.      - Access to this live data cannot be guaranteed.      - If the live version is unavailable use the included sample instead:   collabsphere.json</p>"},{"location":"tutorial/collabsphere_1.html#script-setup","title":"Script Setup","text":"<ol> <li>Create a VoltScript file in src directory called <code>CollabSphere.vss</code>.</li> <li>Add <code>Option Public</code> and <code>Option Declare</code>.</li> <li>Add a USE statement to point to your VotScriptJsonConverter.vss library. If you're using this doc repository, then <code>Use \"../libs/VoltScriptJsonConverter\"</code> should work.</li> </ol>"},{"location":"tutorial/collabsphere_1.html#create-the-classes","title":"Create the Classes","text":"<p>Warning</p> <p>All classes need to be public for VoltScript JSON Converter to create an instance. This is because it will run an <code>Execute</code> statement pointing to this script. If the class is private, the <code>Execute</code> statement will fail.</p>"},{"location":"tutorial/collabsphere_1.html#session-class","title":"Session Class","text":"<ol> <li>Create a class called \"Session\".</li> <li>Add a public String variable called \"debuglog\" (<code>Public debuglog as String</code>).</li> <li>Add the following additional public String variables: id, title, room, start, end, backgroundColor, textColor, and className.</li> <li>Add a constructor (\"New()\") sub that accepts a single argument to set the object's title</li> <li>Add a printSummary method that prints the object's title, time, room, and id</li> </ol> constructor sub <pre><code>Sub New(title As String)\n    Me.title = title\nEnd Sub\n</code></pre> printSummary method <pre><code>Sub printSummary()\n    Print \"Title:   \" &amp; Me.title\n    Print \"Time:    \" &amp; Me.start &amp; | - | &amp; Me.end\n    Print \"Room:    \" &amp; Me.room  \n    Print \"Id:      \" &amp; Me.id\nEnd Sub\n</code></pre>"},{"location":"tutorial/collabsphere_1.html#parse-the-json-file","title":"Parse the JSON file","text":"<p>Open your VSCode IDE and edit your <code>CollabSphere.vss</code> file.</p>"},{"location":"tutorial/collabsphere_1.html#load-the-json","title":"Load the JSON","text":"<ol> <li>Create a <code>Sub Initialize</code>. This is the default method that will be automatically invoked by the  VoltScript processor.  Ensure the name is correct, or the code will not run correctly.</li> <li> <p>Add the following declarations code:</p> <pre><code>Dim job As JsonObject\n\nDim parser As New JsonParser()\nDim helper As New JsonConversionHelper()\nDim sessionConstructor As New JsonCustomConstructor()\nDim jscDebugLog As New JsonScalarConverter()\nDim ogs As Session\n\nDim sessions As Variant\nDim i As Integer\n</code></pre> <p>An explanation of these variables is in order. - <code>job</code>: This is the root JSON Object used for parsing JSON content. - <code>parser</code>: A parsing worker object. - <code>helper</code>: A parsing helper object. - <code>sessionConstructor</code>: This is a customer constructor object, it will allow us to modify constructor argument values. - <code>jscDebugLog</code>: This object is used to convert json scalar values by name. - <code>ogs</code>: A working object instance of the previously defined Session class. - <code>sessions</code>: This is a container for carrying multiple instances of our Session class - <code>i</code>: Nothing more than a simple index counter 1. Add the following implementation code:</p> <pre><code>Call parser.loadFromFile(CurDir() &amp; \"/src/collabsphere.json\") \nSet job = parser.getRootobject\n</code></pre> <p>This will read the collabsphere.json file content into the parser object, and then get the root object from the parser.  </p> <p>Warning</p> <p>CurDir() returns a RUN-TIME representation of the directory from which the script is BEING RUN; not the COMPILE-TIME directory in which that the script file resides. For Visual Studio Code, this is the folder that is open.</p> </li> <li> <p>Add the next block of implementation code:</p> <pre><code>sessions = helper.withCustomConstructor(sessionConstructor.withParam(\"title\", \"\"))._\n    withCustomConverter(\"debug-log\", jscDebugLog.forPropertyName(\"debuglog\"))._\n    jsonArrayToObjects(job, \"Session\", \"CollabSphere\")\n</code></pre> <p>There is A LOT going on in this single line of code. Let's break it down by chunks to see what is going on. - <code>sessions = helper.withCustomConstructor(sessionConstructor.withParam(\"title\", \"\"))._</code>     Here we are telling our helper object we want to use a custom constructor, and we are going to pass the value from the \"title\" of our JSON to our session constructor using the <code>withParam()</code> method.  The second argument to <code>withParam()</code> represents the default value to use in the event that a \"title\" property cannot be found. - <code>withCustomConverter(\"debug-log\", jscDebugLog.forPropertyName(\"debuglog\"))._</code>     The <code>withCustomConverter()</code> method will use a Converter (in this case the JsonScalarConverter instance <code>jscDebugLog</code> to convert a JSON value to a target value identified by the <code>forPropertyName()</code> method).  The reason we need to do this is because our source JSON content contains a \"debug-log\" property, and the hyphen in that property name is ILLEGAL for variable names in VoltScript.  So basically this line of code tells VoltScript to grab the value of debug-log from the JSON, and stuff it into our object instance's variable called debuglog.  It is very simple, and very effective. - <code>jsonArrayToObjects(job, \"Session\", \"CollabSphere\")</code>     The <code>jsonArrayToObjects()</code> method grabs the outermost array of JSON Objects from our root JSON Object (<code>job</code>), then throws the resulting transformation from the prior lines into an array of <code>Session</code> objects.  The second argument indicates that the <code>Session</code> class can be found in the <code>CollabSphere</code> library.  The net result of this line of code is that our <code>sessions</code> Variant object now contains an array of Session object instances.</p> </li> </ol>"},{"location":"tutorial/collabsphere_1.html#search-the-sessions","title":"Search the sessions","text":"<ol> <li> <p>Add the next block of implementation code to loop through our <code>sessions</code> array:</p> <pre><code>For i = Lbound(sessions) to UBound(sessions)\n    If (\"9F3F73226F22F82F862589EB0014CB89\" = Cstr(sessions(i).id)) Then\n        Set ogs = sessions(i)\n        Exit For\n    End If\nNext\n</code></pre> <p>This code is fairly simple.  It iterates through our sessions instances and for each one tests to see if the <code>id</code> property is equal to \"9F3F73226F22F82F862589EB0014CB89\".  If a match is found it sets the <code>ogs</code> instance and bails out of the loop. Note: \"9F3F73226F22F82F862589EB0014CB89\" is the known UniversalID of the underlying session document from which the JSON was populated. </p> </li> </ol>"},{"location":"tutorial/collabsphere_1.html#print-the-results","title":"Print the results","text":"<ol> <li> <p>Add the final block of implementation code to print out the results:</p> <pre><code>If (ogs is Nothing) Then\n    Print \"We could not find the OGS of CollabSphere\"\nElse\n    Print \"Found OGS of CollabSphere as session \" &amp; i\n    Call ogs.printSummary()\nEnd If\n</code></pre> <p>If the <code>ogs</code> instance was not found then print out that we could not find it.  Otherwise print out the summary information from the instance.</p> </li> </ol>"},{"location":"tutorial/collabsphere_1.html#run-your-script","title":"Run your Script","text":"<ol> <li>Use the <code>&lt;command&gt; + &lt;shift&gt; + &lt;p&gt;</code> sequence (<code>&lt;ctrl&gt; + &lt;shift&gt; + &lt;p&gt;</code> on Windows) to bring up the Command Selector.  Choose VoltScript:Save &amp; Run Script (or just press enter) to save and run the script.</li> <li>A Secondary text box will appear.  This text box is for typing in any additional command-line parameters for the VoltScript processor.  No additional parameters are needed, so just press .   <li>Your script should now run and any output (or debug messages) should appear in the VSCode Terminal window (directly below your editor pane). Correct any errors that may be reported and continue running until you get a successful result.</li> The Opening General Session for ColabSphere 2023 should be: <ul> <li>Title:   OGS101 - Opening General Session - HCL Digital Solutions NEXT</li> <li>Time:    2023-08-30T09:00:00 - 2023-08-30T10:30:00</li> <li>Room:    Auditorium</li> <li>Id:      9F3F73226F22F82F862589EB0014CB89</li> </ul>"},{"location":"tutorial/collabsphere_2.html","title":"Extend CollabSphere Parsing","text":""},{"location":"tutorial/collabsphere_2.html#pre-requisites","title":"Pre-Requisites","text":"<ol> <li>Complete Parsing Nobel Laureates</li> <li>Complete Parsing CollabSphere Sessions</li> </ol>"},{"location":"tutorial/collabsphere_2.html#objectives","title":"Objectives","text":"<ol> <li>Remove unnecessary variables from the Session class.</li> <li>Add additional arguments to the Session class Constructor</li> <li>Add dynamic getter properties to the Session class.</li> <li>Make use of the VoltScript <code>return</code> statement.</li> <li>Make use of the VoltScript <code>||</code> short-circuiting or operator.</li> <li>Extend your knowledge of helper methods within the VoltScript Json Converter Library</li> <li>Create additional Custom Converters</li> </ol>"},{"location":"tutorial/collabsphere_2.html#script-revision","title":"Script Revision","text":""},{"location":"tutorial/collabsphere_2.html#initial-updates","title":"Initial Updates","text":"<ol> <li>Launch your VSCode IDE, then open your working project used for the previous tutorials.</li> <li>Within the IDE Explorer, copy and paste your <code>CollabSphere.vss</code> file as <code>CollabSphere_2.vss</code>.</li> <li> <p>Find the following block of code (in <code>Sub Initialize</code>):</p> <pre><code>sessions = helper.withCustomConstructor(sessionConstructor.withParam(\"title\", \"\"))._\n    withCustomConverter(\"debug-log\", jscDebugLog.forPropertyName(\"debuglog\"))._\n    jsonArrayToObjects(job, \"Session\", \"CollabSphere\")\n</code></pre> <p>and change <code>CollabSphere</code> to <code>CollabSphere_2</code>. 1. Save and Run the Script.  Your output should be identical to that when running the script from the previous tutorial.</p> </li> </ol>"},{"location":"tutorial/collabsphere_2.html#modify-the-session-class","title":"Modify the Session Class","text":"<p>Clean Code is Good Code</p> <ol> <li>Find the <code>Session</code> class within your code, and remove the Public String variables <code>debuglog</code>, <code>backgroundColor</code>, <code>textColor</code>, and <code>className</code>.  These variables were initially created to allow for simple importation from the underlying JSON content, but they will never be used, so there is no reason to keep them.  </li> <li>Change the Public String variable names from <code>id, start</code>, and <code>end</code> to <code>unid, startTime</code>, and <code>endTime</code> respectively.</li> <li>Revise the constructor to accept and additional initial argument <code>unid</code>, and use it to set the Object's <code>unid</code> value.</li> <li>Add the Private String variables <code>sessiondate_</code> and <code>sessiontime_</code> to the declarations area of the <code>Session</code> class.  </li> <li> <p>Add the following getter property:</p> <pre><code>Property Get SessionDate As String \n    Dim chunks as Variant \n\n    If (Len(Me.sessiondate_) &gt; 0) Then return Me.sessiondate_\n\n    chunks = split(Me.startTime, |T|)\n    if (ubound(chunks) &gt; 0) Then Me.sessiondate_ = cstr(chunks(0))\n\n    return Me.sessiondate_ \nEnd Property\n</code></pre> <p>This code block makes use of the VoltScript <code>return</code> statement in line 4.  In this situation, the <code>return</code> statement immediately ceases processing of the property script and returns the value of <code>Me.sessiondate_</code> to the calling code, which alleviates needing to: 1. Explicitly set the value of <code>SessionDate</code> to that of <code>Me.sessiondate_</code>. 1. Add an <code>Else</code> and <code>End If</code> to the <code>If</code> statement, or explicitly call <code>Exit Property</code>.</p> short-circuit comparisons <p>In LotusScript (from which VoltScript evolved), <code>And</code> and <code>Or</code> comparisions always evaluate every condition (both sides of the comparison operator), which can result in ineffecient code (or sometimes code failures).   Short Circuit comparisons (<code>||</code> for <code>Or</code>, and <code>&amp;&amp;</code> for <code>And</code>) will cease comparison at the first condition which logically ends the need for additional comparisons, and will not evaulate additional conditions. The following code example should help:</p> <pre><code>Dim a as Integer\nDim b as Integer\nDim c as Integer\n\na = 1 \nb = 2 \nc = 3 \n\nIf (a &lt; b) || (b &lt; c) Then Print \"True: evaluated first condition, skipped second condition\"\nIf (a &lt; b) &amp;&amp; (b &lt; c) Then Print \"True: evaluated both conditions\"\nIf (a &gt; b) || (b &gt; c) Then Print \"False: evaluated both conditions\"\nIf (a &gt; b) &amp;&amp; (b &gt; c) Then Print \"False: evaluted first condition, skipped second condition\"\n</code></pre> </li> <li> <p>Add the following getter property:</p> <pre><code>Property Get SessionTime As String \n    Dim chunks as Variant \n    Dim strTemp as String \n\n    If (Len(Me.sessiontime_) &gt; 0) Then return Me.sessiontime_\n\n    If (Len(Me.SessionDate) &lt; 1) || (Len(Me.endTime) &lt; 1) Then return\n\n    chunks = split(Me.startTime, |T|)\n    strTemp = Left$(chunks(Ubound(chunks)), 5)\n\n    chunks = split(me.endTime, |T|)\n    chunks(0) = strTemp \n    strTemp = Left$(chunks(Ubound(chunks)), 5)\n    chunks(1) = strTemp \n    Me.sessiontime_ = Join(chunks, | - |)\n\n    return Me.sessiontime_ \nEnd Property \n</code></pre> <p>As in the previous step, this code also makes use of the <code>return</code> statment.  However, it does something rather interesting.  If you take a closer look at line 6:</p> <pre><code>If (Len(Me.SessionDate) &lt; 1) || (Len(Me.endTime) &lt; 1) Then return\n</code></pre> <p>You will notice the use of a double-pipe (<code>||</code>).  In both LotusScript and VoltScript the use of a double-pipe can indicate an empty string (just as <code>{}</code> or <code>\"\"</code> does).  In VoltScript, this double-pipe also indicates a short-circuit <code>Or</code> comparison, depending upon the context in which it appears.</p> <p>Because this line of code is performing logical comparison operations (an <code>If</code> statment) the VoltScript processor recognizes that the double-pipe is a comparison operator, not an empty string indicator.</p> <p>You will also notice that line 5 ends with a <code>return</code> statement, but has no following value.  This causes processing of the current block to immediately stop and return to the calling code.  Because the block is a <code>Property</code> that would normally return a String, the default empty string <code>\"\"</code> value is returned to the calling code.</p> <p>Tip</p> <p>The use of <code>return</code>, <code>||</code>, and <code>&amp;&amp;</code> statments result in cleaner, more efficient, and easier to understand code.  </p> </li> <li> <p>Revise the <code>printSummary</code> method to print the values of <code>SessionDate</code> and <code>SessionTime</code>, replace <code>unid</code> with <code>id</code>, and to no longer print values for <code>start</code> or <code>end</code>.</p> </li> </ol> Revised Session class <pre><code>Class Session\n    Private sessiondate_ As String \n    Private sessiontime_ As String \n    Public unid As String \n    Public title As String\n    Public room As String \n    Public startTime As String\n    Public endTime As String\n\n    Sub New(unid as String, title as String)\n        Me.unid = unid\n        Me.title = title \n    End Sub\n\n    Property Get SessionDate As String \n        Dim chunks as Variant \n\n        If (Len(Me.sessiondate_) &gt; 0) Then return Me.sessiondate_\n\n        chunks = split(Me.startTime, |T|)\n        if (ubound(chunks) &gt; 0) Then Me.sessiondate_ = cstr(chunks(0))\n\n        return Me.sessiondate_ \n    End Property \n\n    Property Get SessionTime As String \n        Dim chunks as Variant \n        Dim strTemp as String \n\n        If (Len(Me.sessiontime_) &gt; 0) Then return Me.sessiontime_\n        If (Len(Me.SessionDate) &lt; 1) || (Len(Me.endTime) &lt; 1) Then return || \n\n        chunks = split(Me.startTime, |T|)\n        strTemp = Left$(chunks(Ubound(chunks)), 5)\n\n        chunks = split(me.endTime, |T|)\n        chunks(0) = strTemp \n        strTemp = Left$(chunks(Ubound(chunks)), 5)\n        chunks(1) = strTemp \n        Me.sessiontime_ = Join(chunks, | - |)\n\n        return Me.sessiontime_ \n    End Property \n\n    Sub printSummary()\n        Print \"Title:   \" &amp; Me.title \n        Print \"Date:    \" &amp; Me.SessionDate\n        Print \"Time:    \" &amp; Me.SessionTime \n        Print \"Room:    \" &amp; Me.room  \n        Print \"Unid:    \" &amp; Me.unid\n    End Sub\n\nEnd Class\n</code></pre>"},{"location":"tutorial/collabsphere_2.html#modify-code-that-uses-voltscript-json-helper-methods","title":"Modify code that uses VoltScript Json Helper methods","text":"<ol> <li> <p>Find the following block of code (in <code>Sub Initialize</code>):</p> <pre><code>sessions = helper.withCustomConstructor(sessionConstructor.withParam(\"title\", \"\"))._\n    withCustomConverter(\"debug-log\", jscDebugLog.forPropertyName(\"debuglog\"))._\n    jsonArrayToObjects(job, \"Session\", \"CollabSphere_2\")\n</code></pre> </li> <li> <p>Insert the code <code>.ignoreLabel(\"debug-log\")</code> between <code>sessions = helper</code> and <code>.withCustomConstructor</code>.  The <code>.ignoreLabel()</code> method instructs the JsonConverterHelper object instance (<code>helper</code>) to ignore the specified label (and by extension the label's associated value) when processing the JSON content.  In this case we no longer want to use the <code>debug-log</code> elements within the JSON content.</p> </li> <li>Find the block of code <code>withCustomConverter(\"debug-log\", jscDebugLog.forPropertyName(\"debuglog\"))._</code> and remove it entirely.  Because we have instructed the helper object to ignore the <code>debug-log</code> elements, we no longer have any need to convert their values to the target objects's <code>debuglog</code> variables (which we removed as the first step in modifying the Session class).</li> <li>Find the code <code>jsonArrayToObjects</code> and immediately prior to it insert additional <code>.ignoreLabel()</code> method calls for the other Public String variables that we previously removed (<code>backgroundColor</code>, <code>textColor</code>, and <code>className</code>).</li> </ol>"},{"location":"tutorial/collabsphere_2.html#modify-code-that-uses-voltscript-json-converter-methods","title":"Modify code that uses VoltScript Json Converter methods","text":"<ol> <li> <p>Because we have renamed the variables <code>start</code> and <code>end</code> in the <code>Session</code> class to <code>startTime</code> and <code>endTime</code>, we need perform some conversions when processing the JSON into our object instances -similar to the conversion for <code>debug-log</code> that we have removed.  In the declarations section of <code>Sub Initialize</code>, find the line of code <code>Dim jscDebugLog As New JsonScalarConverter()</code>, and replace it with the following:</p> <pre><code>Dim jscStart As New JsonScalarConverter()\nDim jscEnd As New JsonScalarConverter()\n</code></pre> </li> </ol> <p>The reason for this is that each unique conversion to be performed requires a distinct converter object instance.</p> <ol> <li> <p>Insert the following code immediately prior to <code>jsonArrayToObjects(job, \"Session\", \"CollabSphere_2\")</code></p> <pre><code>withCustomConverter(\"start\", jscStart.forPropertyName(\"startTime\"))._\nwithCustomConverter(\"end\", jscEnd.forPropertyName(\"endTime\"))._\n</code></pre> </li> </ol> <p>This tells the code to take the JSON values from <code>start</code> and <code>end</code> and assign them to the object's variables <code>startTime</code> and <code>endTime</code>.  </p> Loading the sessions <pre><code>sessions = helper.ignoreLabel(\"debug-log\")._\n    ignoreLabel(\"backgroundColor\")._\n    ignoreLabel(\"textColor\")._\n    ignoreLabel(\"className\")._\n    withCustomConstructor(sessionConstructor.withParam(\"id\",\"\").withParam(\"title\", \"\"))._\n    withCustomConverter(\"start\", jscStart.forPropertyName(\"startTime\"))._\n    withCustomConverter(\"end\", jscEnd.forPropertyName(\"endTime\"))._\n    jsonArrayToObjects(job, \"Session\", \"CollabSphere_2\")\n</code></pre>"},{"location":"tutorial/collabsphere_2.html#revise-the-search-logic","title":"Revise the search logic","text":"<ol> <li> <p>This final change is a very simple one.  Find the line of code</p> <pre><code>If (\"9F3F73226F22F82F862589EB0014CB89\" = Cstr(sessions(i).id)) Then\n</code></pre> <p>and change the <code>.id</code> reference to <code>.unid</code>.  </p> </li> </ol>"},{"location":"tutorial/collabsphere_2.html#run-your-script","title":"Run your Script","text":"<ol> <li>Use the <code>&lt;command&gt; + &lt;shift&gt; + &lt;p&gt;</code> sequence (<code>&lt;ctrl&gt; + &lt;shift&gt; + &lt;p&gt;</code> on Windows) to bring up the Command Selector.  Choose VoltScript:Save &amp; Run Script (or just press enter) to save and run the script.</li> <li>A Secondary text box will appear.  This text box is for typing in any additional command-line parameters for the VoltScript processor.  No additional parameters are needed, so just press .   <li>Your script should now run and any output (or debug messages) should appear in the VSCode Terminal window (directly below your editor pane). Correct any errors that may be reported and continue running until you get a successful result.</li> The Opening General Session for ColabSphere 2023 should be: <ul> <li>Title:   OGS101 - Opening General Session - HCL Digital Solutions NEXT</li> <li>Date:    2023-08-30</li> <li>Time:    09:00 - 10:30</li> <li>Room:    Auditorium</li> <li>Unid:    9F3F73226F22F82F862589EB0014CB89</li> </ul> <p>Challenge Yourself</p> <p>For more advanced VoltScript, try the following:</p> <ul> <li>Add a getter property to the session class that will extract the CollabSphere session code from the beginning of the title. </li> <li>Revise the search logic to search for a specific session code instead of a UniversalID </li> <li>Revise the SessionDate property of the session to include the name of the month</li> <li>Add a getter property to the session class that returns the title with the session code removed.</li> </ul> Challenge VoltScript <pre><code>%REM\n    Copyright 2022-2023 HCL America, Inc.\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, \n    software distributed under the License is distributed on an \"AS IS\" BASIS, \n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n    See the License for the specific language governing permissions and limitations under the License   \n%END REM\n\nOption Public\nOption Declare\nUse \"../src/VoltScriptJsonConverter\"\n\nProperty Get MonthNames as Variant \n    Static result(1 to 12) as String \n    Static isLoaded as Boolean \n\n    If Not isLoaded Then \n        result(1) = |January|\n        result(2) = |February|\n        result(3) = |March|\n        result(4) = |April|\n        result(5) = |May|\n        result(6) = |June|\n        result(7) = |July|\n        result(8) = |August|\n        result(9) = |September|\n        result(10) = |October|\n        result(11) = |November|\n        result(12) = |December|\n        isLoaded = True \n    End If \n\n    MonthNames = result \nEnd Property \n\nClass Session\n    Private id_ as String \n    Private sessiondate_ As String \n    Private sessiontime_ As String \n    Public unid as String\n    Public title as String\n    Public startTime as String\n    Public endTime as String\n    Public room as String \n\n    Public Property Get Id as String \n        Dim chunks as Variant \n\n        If (Len(me.id_) &lt; 1) Then \n            chunks = split(Me.title, | - |)\n            Me.id_ = Trim$(chunks(0))\n        End If \n\n        Id = Me.id_ \n    End Property \n\n    Property Get SessionDate As String \n        Dim chunks as Variant \n        Dim dateparts(2) As String \n\n        If (Len(Me.sessiondate_) &gt; 0) Then return me.sessiondate_\n\n        chunks = split(me.startTime, |T|)\n        If (ubound(chunks) &gt; 0) Then \n            chunks = split(chunks(Lbound(chunks)), |-|)\n\n            dateParts(0) = chunks(2)\n            dateParts(1) = MonthNames(cint(chunks(1)))\n            dateParts(2) = chunks(0)\n            me.sessiondate_ = Join(dateParts, | |)\n        End If \n\n        return me.sessiondate_ \n    End Property \n\n    Property Get SessionTime As String \n        Dim chunks as Variant \n        Dim strTemp as String \n\n        If (Len(Me.sessiontime_) &gt; 0) Then return me.sessiontime_\n\n        If (Len(me.SessionDate) &lt; 1) || (Len(Me.endTime) &lt; 1) Then return\n\n        chunks = split(me.startTime, |T|)\n        strTemp = Left$(chunks(Ubound(chunks)), 5)\n\n        chunks = split(me.endTime, |T|)\n        chunks(0) = strTemp \n        strTemp = Left$(chunks(Ubound(chunks)), 5)\n        chunks(1) = strTemp \n        Me.sessiontime_ = Join(chunks, | - |)\n\n        return me.sessiontime_ \n    End Property \n\n    Property Get SessionName As String \n        If (len(Me.Id) &gt; 0) Then \n            return Trim$(Mid$(Me.title, Len(Me.Id &amp; | - |), Len(Me.title)))\n        Else \n            return  Me.title  \n        End If \n    End Property \n\n    Sub New(unid as String, title as String)\n        Me.unid = unid\n        Me.title = title \n    End Sub\n\n    Sub printSummary()\n        Print \"Id:      \" &amp; Me.Id\n        Print \"Session: \" &amp; Me.SessionName \n        Print \"Date:    \" &amp; Me.SessionDate\n        Print \"Time:    \" &amp; Me.SessionTime \n        Print \"Room:    \" &amp; Me.room  \n        Print \"Unid:    \" &amp; Me.unid\n    End Sub\nEnd Class\n\nSub Initialize\n    Dim job As JsonObject\n\n    Dim parser As New JsonParser()\n    Dim helper As New JsonConversionHelper()\n    Dim sessionConstructor As New JsonCustomConstructor()\n    Dim jscStart As New JsonScalarConverter()\n    Dim jscEnd As New JsonScalarConverter()\n    Dim sess As Session\n\n    Dim sessions As Variant\n    Dim i As Integer\n\n    Call parser.loadFromFile(CurDir() &amp; \"/samples/collabsphere.json\") \n    ' CurDir() as referenced above is set at RUN-TIME\n    ' it represents the directory from which the script is BEING RUN; \n    ' not the COMPILE-TIME directory in which that the script file resides.\n\n    Set job = parser.getRootobject\n\n    ' jscStart.forPropertyName and jscEnd.forPropertyName are both run before either withCustomConverter is run\n    ' So if we use the same variable, both custom converters write to endTime\n    sessions = helper.ignoreLabel(\"className\")._\n        ignoreLabel(\"debug-log\")._\n        ignoreLabel(\"backgroundColor\")._\n        ignoreLabel(\"textColor\")._\n        ignoreLabel(\"className\")._\n        withCustomConstructor(sessionConstructor.withParam(\"id\",\"\").withParam(\"title\", \"\"))._\n        withCustomConverter(\"start\", jscStart.forPropertyName(\"startTime\"))._\n        withCustomConverter(\"end\", jscEnd.forPropertyName(\"endTime\"))._\n        jsonArrayToObjects(job, \"Session\", \"CollabSphere_challenge\")\n\n    For i = Lbound(sessions) to UBound(sessions)\n        ' use Id Property \n        If (|DEV113| = Cstr(sessions(i).Id)) Then\n            Set sess = sessions(i)\n            Exit For\n        End If\n    Next\n\n    If (sess is Nothing) Then\n        Print \"We could not find the VoltScript Unit Testing\"\n    Else\n        Print \"Found VoltScript Unit Testing! \" &amp; i\n        sess.printSummary\n    End If\nEnd Sub\n</code></pre>"},{"location":"tutorial/laureates.html","title":"Parse Nobel Laureates","text":"<p>Note</p> <p>The file is quite large, so running the script takes some time. You can remove some data to improve performance.</p>"},{"location":"tutorial/laureates.html#setup-the-project","title":"Setup the project","text":"<ol> <li>Ensure your atlas-settings.json is set up with authentication for Volt MX Marketplace and github.com.</li> <li>Create a folder for the project.</li> <li>Create an atlas.json and complete mandatory elements. Set <code>sourceDir</code> to \"src\", <code>libsDir</code> to \"\"libs\" and <code>vsesDir</code> to \"vses\".</li> <li> <p>In the repositories element, add the following repository:</p> <pre><code>{\n        \"id\": \"hcl-github\",\n        \"type\": \"github\",\n        \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\"\n    }\n</code></pre> </li> <li> <p>In the dependencies element, add the following dependency:</p> <pre><code>        {\n        \"library\": \"voltscript-testing\",\n        \"version\": \"latest\",\n        \"module\": \"VoltScriptTesting.vss\",\n        \"repository\": \"hcl-github\"\n    }\n</code></pre> </li> <li> <p>Save the atlas.json and ensure no validation errors.</p> </li> <li>Run dependency management (Ctrl + Chift + P / Cmd + Shift + P and choose \"VoltScript: Install Dependencies\").</li> <li>Ensure libs contains \"VoltScriptJsonConverter\" and vses contains the JSONVSE extensions.</li> </ol>"},{"location":"tutorial/laureates.html#download-the-file","title":"Download the file","text":"<ol> <li>Access the JSON data from https://api.nobelprize.org/v1/prize.json.</li> <li>Download the data to a file called <code>nobel.json</code> in the src directory.</li> </ol>"},{"location":"tutorial/laureates.html#create-the-classes","title":"Create the Classes","text":""},{"location":"tutorial/laureates.html#script-setup","title":"Script Setup","text":"<ol> <li>Create a VoltScript file in src directory called <code>NobelPrizes.vss</code>.</li> <li>Add <code>Option Declare</code> and <code>Option Public</code>.</li> <li>Add a USE statement to point to your VotScriptJsonConverter.vss library. If you're using this doc repository, then <code>Use \"../libs/VoltScriptJsonConverter\"</code> should work.</li> </ol>"},{"location":"tutorial/laureates.html#prize-class","title":"Prize Class","text":"<ol> <li>Create a class called \"Prize\".</li> <li>Add a public String variable called \"year\" (<code>Public year as String</code>).</li> <li>Add a public String variable called \"category\".</li> <li>Add a public String variable called \"overallMotivation.</li> <li>Add a public Variant variable called \"laureates\".</li> </ol> <p>Warning</p> <p>All classes need to be public for VoltScript JSON Converter to create an instance. This is because it will run an <code>Execute</code> statement pointing to this script. If the class is private, the <code>Execute</code> statement will fail.</p>"},{"location":"tutorial/laureates.html#laureate-class","title":"Laureate Class","text":"<ol> <li>Create a class called \"Laureate\"</li> <li>Add a public String variable called \"id\".</li> <li>Add a public String variable called \"firstName\".</li> <li>Add a public String variable called \"surname\".</li> <li>Add a public String variable called \"motivation\".</li> <li>Add a public String variable called \"share\".</li> <li>Add a <code>getName()</code> function that returns a String. Return <code>Me.firstName &amp; \" \" &amp; Me.surname</code>.</li> </ol>"},{"location":"tutorial/laureates.html#loading-the-json-file","title":"Loading the JSON file","text":"<ol> <li>Create a <code>Sub Initialize</code>. This will be triggered automatically by VoltScript when the script runs. Ensure the name is correct, or the code won't be triggered.</li> <li> <p>Add the following code:</p> <pre><code>Dim parser as new JsonParser()\nDim root as JsonObject\nDim prizes as Variant\n\nCall parser.loadFromFile(CurDir() &amp; \"/src/nobel.json\")\nSet root = parser.getRootObject\nprizes = root.getChild(\"prizes\").getChildren()\n</code></pre> <p>This loads the file and gets the \"prizes\" JSON object.</p> </li> </ol> <p>Warning</p> <p>CurDir() returns a RUN-TIME representation of the directory from which the script is BEING RUN; not the COMPILE-TIME directory in which that the script file resides. For Visual Studio Code, this is the folder that is open.</p> <p>Note</p> <p>You can test the code by adding <code>Print root.getChild(\"prizes\").shortValue()</code>, to verify it's loaded the file correctly. You can also use a Try...Catch...End Try block to Catch errors.</p>"},{"location":"tutorial/laureates.html#converting-the-json","title":"Converting the JSON","text":"<ol> <li> <p>Add the following code:</p> <pre><code>Dim helper as New JsonConversionHelper\nDim converter as New JsonBasicObjectArrayConverter(\"Laureate\", \"NobelPrizes\")\nDim prizeObj as JsonObject\nDim prize as Prize\nDim i as Integer\nDim prizeList List as Prize\n\nFor i = 0 to UBound(prizes)\n    Set prizeObj = prizes(i)\n    Set prize = helper.withCustomConverter(\"laureates\", converter)._\n        toObject(prizeObj, \"Prize\", \"NobelPrizes\")._\n        fromJson(prizeObj)\n    Set prizeList(prize.year &amp; \"-\" &amp; prize.category) = prize\nNext\n</code></pre> </li> <li> <p>You can then check information based on properties of the VoltScript objects. For example, <code>Print prizeList(\"2021-economics\").laureates(0).getName()</code> will print the name of the first Laureate for the 2021 Economics prize.</p> </li> </ol> Success <p>The name for the first Laureate for the 2021 Economics Nobel Prize was David Card.</p> <p>Challenge Yourself</p> <p>For more advanced VoltScript, Try:</p> <ul> <li>Iterating and only loading prizes for 2021, exiting after 2021 is completed.</li> <li>Navigating directly to the JSON object for prizes for 2021 and only loading those prizes.</li> <li>Manually parsing the JSON using JsonLSX to get the same information.</li> </ul>"}]}